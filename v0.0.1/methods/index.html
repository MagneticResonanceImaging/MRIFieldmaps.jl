<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · MRIFieldmaps.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://MagneticResonanceImaging.github.io/MRIFieldmaps.jl/stable/methods/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MRIFieldmaps.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Methods</a><ul class="internal"><li><a class="tocitem" href="#Methods-list"><span>Methods list</span></a></li><li><a class="tocitem" href="#Methods-usage"><span>Methods usage</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/examples/01-overview/">MRIFieldmaps overview</a></li><li><a class="tocitem" href="../generated/examples/02-b0map/">B0 field map</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Methods</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MagneticResonanceImaging/MRIFieldmaps.jl/blob/main/docs/src/methods.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Methods-list"><a class="docs-heading-anchor" href="#Methods-list">Methods list</a><a id="Methods-list-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-list" title="Permalink"></a></h2><ul><li><a href="#MRIFieldmaps.MRIFieldmaps"><code>MRIFieldmaps.MRIFieldmaps</code></a></li><li><a href="#MRIFieldmaps.Echotime"><code>MRIFieldmaps.Echotime</code></a></li><li><a href="#MRIFieldmaps.RealU"><code>MRIFieldmaps.RealU</code></a></li><li><a href="#MRIFieldmaps.b0init-Union{Tuple{Te}, Tuple{D}, Tuple{AbstractArray{&lt;:Complex, D}, Union{AbstractVector{&lt;:Te}, Tuple{Vararg{var&quot;#s2&quot;, N}} where {N, var&quot;#s2&quot;&lt;:Te}}}} where {D, Te&lt;:Number}"><code>MRIFieldmaps.b0init</code></a></li><li><a href="#MRIFieldmaps.b0map"><code>MRIFieldmaps.b0map</code></a></li><li><a href="#MRIFieldmaps.b0map-Tuple{AbstractVector{&lt;:Number}, AbstractMatrix{&lt;:Complex}, AbstractVector{&lt;:Real}, Union{AbstractVector{&lt;:T}, Tuple{Vararg{var&quot;#s2&quot;, N}} where {N, var&quot;#s2&quot;&lt;:T}} where T, AbstractArray{&lt;:Bool}}"><code>MRIFieldmaps.b0map</code></a></li><li><a href="#MRIFieldmaps.b0model-Union{Tuple{Tx}, Tuple{Tf}, Tuple{Te}, Tuple{D}, Tuple{AbstractArray{Tf, D}, AbstractArray{Tx, D}, Union{Tuple{Vararg{Te, N}} where N, AbstractVector{Te}}}} where {D, Te&lt;:Number, Tf&lt;:Number, Tx&lt;:Number}"><code>MRIFieldmaps.b0model</code></a></li><li><a href="#MRIFieldmaps.b0scale-Union{Tuple{Te}, Tuple{AbstractArray{&lt;:Complex}, Union{Tuple{Vararg{Te, N}} where N, AbstractVector{Te}}}} where Te&lt;:Number"><code>MRIFieldmaps.b0scale</code></a></li><li><a href="#MRIFieldmaps.coil_combine-Tuple{AbstractArray{&lt;:Complex}, AbstractArray{&lt;:Complex}}"><code>MRIFieldmaps.coil_combine</code></a></li><li><a href="#MRIFieldmaps.spdiff-Tuple{Tuple{Vararg{Int64, N}} where N}"><code>MRIFieldmaps.spdiff</code></a></li><li><a href="#MRIFieldmaps.spdiff1-Tuple{Int64}"><code>MRIFieldmaps.spdiff1</code></a></li><li><a href="#MRIFieldmaps.spdiff2-Tuple{Int64}"><code>MRIFieldmaps.spdiff2</code></a></li></ul><h2 id="Methods-usage"><a class="docs-heading-anchor" href="#Methods-usage">Methods usage</a><a id="Methods-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-usage" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MRIFieldmaps.MRIFieldmaps" href="#MRIFieldmaps.MRIFieldmaps"><code>MRIFieldmaps.MRIFieldmaps</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">MRIFieldmaps</code></pre><p>Module <code>MRIFieldmaps</code> exports methods for fieldmap estimation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/MRIFieldmaps.jl/blob/cb68f87669c68a116af1e38f56d90b4c0553d0b8/src/MRIFieldmaps.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIFieldmaps.Echotime" href="#MRIFieldmaps.Echotime"><code>MRIFieldmaps.Echotime</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Echotime{T} = Union{AbstractVector{&lt;:T}, NTuple{N,&lt;:T} where N}</code></pre><p>The echo times can be a vector or a Tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/MRIFieldmaps.jl/blob/cb68f87669c68a116af1e38f56d90b4c0553d0b8/src/MRIFieldmaps.jl#L15-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIFieldmaps.RealU" href="#MRIFieldmaps.RealU"><code>MRIFieldmaps.RealU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RealU</code></pre><p>A data type that is just <code>Number</code> but is to be thought of as <code>Union{Real, Unitful}</code> without needing a dependence on the <code>Unitful</code> package.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/MRIFieldmaps.jl/blob/cb68f87669c68a116af1e38f56d90b4c0553d0b8/src/MRIFieldmaps.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIFieldmaps.b0init-Union{Tuple{Te}, Tuple{D}, Tuple{AbstractArray{&lt;:Complex, D}, Union{AbstractVector{&lt;:Te}, Tuple{Vararg{var&quot;#s2&quot;, N}} where {N, var&quot;#s2&quot;&lt;:Te}}}} where {D, Te&lt;:Number}" href="#MRIFieldmaps.b0init-Union{Tuple{Te}, Tuple{D}, Tuple{AbstractArray{&lt;:Complex, D}, Union{AbstractVector{&lt;:Te}, Tuple{Vararg{var&quot;#s2&quot;, N}} where {N, var&quot;#s2&quot;&lt;:Te}}}} where {D, Te&lt;:Number}"><code>MRIFieldmaps.b0init</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">finit = b0init(ydata, echotime; kwargs...)</code></pre><p>Classic B0 field map estimation based on the phase difference of complex images at two different echo times. If sensitivity maps (<code>smap</code>) are provided, complex coil combination is done first. This code works with images of arbitrary dimensions (2D, 3D, etc.), and with multiple coils.</p><p>In the usual case where <code>echotime</code> has units of seconds, the returned B0 fieldmap will have units of Hz.</p><p>If <code>df</code> is nonempty (which always holds for water-fat case), then perform discrete maximum-likelihood estimation using <code>fdict</code>.</p><p><strong>In</strong></p><ul><li><code>ydata (dims..., nc, ne)</code> <code>ne</code> sets of complex images for <code>nc ≥ 1</code> coils</li><li><code>echotime (ne)</code> vector of <code>ne ≥ 2</code> echo times (only first 2 are used)</li></ul><p><strong>Options</strong></p><ul><li><code>smap (dims..., nc)</code> complex coil maps; default ones</li><li><code>threshold</code> set <code>finit</code> values where <code>|y1| &lt; threshold * max(|y1|)</code>  to the mean of the &quot;good&quot; values where <code>|y1| ≥ threshold * max(|y1|)</code>.  default: <code>0.1</code></li></ul><p><strong>Options for water-fat case:</strong></p><ul><li><code>df</code> Δf values in water-fat imaging (def: <code>[]</code>) units Hz, e.g., <code>[440]</code> at 3T</li><li><code>relamp</code> relative amplitudes in multi-species water-fat (def: <code>[]</code>)</li><li><code>fband</code> frequency bandwidth for <code>fdict; default</code>floor(1 / minimum(echo time spacing))`</li><li><code>nf</code> number of discrete frequencies to try; default <code>1+floor(fband)</code> so ≈1Hz spacing</li><li><code>fdict</code> &quot;dictionary&quot; of discrete frequency values to try; default <code>LinRange(-1/2,1/2,nf) * fband</code></li></ul><p><strong>Out</strong></p><ul><li><code>finit</code> initial B0 fieldmap estimate in Hz</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/MRIFieldmaps.jl/blob/cb68f87669c68a116af1e38f56d90b4c0553d0b8/src/b0init.jl#L11-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIFieldmaps.b0map" href="#MRIFieldmaps.b0map"><code>MRIFieldmaps.b0map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(fhat, times, out) = b0map(ydata, echotime; kwargs...)</code></pre><p>Field map estimation from multiple (<code>ne ≥ 2</code>) echo-time images, using preconditioned nonlinear CG (NCG) with a monotonic line search. This code works with images of arbitrary dimensions (2D, 3D, etc.), and with multiple coils.</p><p>Caution: single coil data must be reshaped to size <code>(dims..., 1, ne)</code>.</p><p>The cost function for the single-coil case is: <code>cost(w) = ∑_{j=1}^{#voxel} ∑_{m=1}^ne ∑_{n=1}^ne     |y_{mj} y_{nj}| wj (1 - cos(w_j * (t_m - t_n) + ∠y_{ni} - ∠y_{mj})) + R(w)</code> where <code>t_n</code> denotes the echo time of the <code>n</code>th scan and <code>R(w) = 0.5 * | C * w |^2</code> is a quadratic roughness regularizer based on 1st-order or 2nd-order finite differences. See the documentation for the general multi-coil case.</p><p>The initial field map <code>finit</code> and output <code>fhat</code> are field maps in Hz, but internally the code works with <code>ω = 2π f</code> (rad/s).</p><p><strong>In</strong></p><ul><li><code>ydata (dims..., nc, ne)</code> <code>ne</code> sets of complex images for <code>nc ≥ 1</code> coils</li><li><code>echotime::Echotime (ne ≥ 2)</code> echo time offsets (in seconds)</li></ul><p><strong>Options</strong></p><ul><li><code>finit (dims)</code> initial fieldmap estimate (in Hz); default from <code>b0init()</code></li><li><code>smap (dims..., nc)</code> complex coil maps; default <code>ones(size(ydata)[1:end-1])</code></li><li><code>mask (dims...)</code> logical reconstruction mask; default: <code>trues(size(finit))</code></li><li><code>ninner</code> # of inner iterations for monotonic line search default: <code>3</code> inner iterations</li><li><code>b0init_args::NamedTuple = (;)</code> options for <code>b0init</code>, such as <code>threshold</code></li><li><code>niter</code> # of outer iterations (def: <code>30</code>)</li><li><code>order</code> order of the finite-difference matrix (def: <code>2</code>)</li><li><code>l2b</code> <code>log2</code> of regularization parameter (def: <code>-6</code>)</li><li><code>gamma_type</code> CG direction:<ul><li><code>:PR</code> = Polak-Ribiere (default)</li><li><code>:FR</code> = Fletcher-Reeves</li></ul></li><li><code>precon</code> Preconditioner:<ul><li><code>:I</code> (nothing)</li><li><code>:diag</code></li><li><code>:chol</code> may require too much memory</li><li><code>:ichol</code> (default)</li></ul></li><li><code>reset</code> # of iterations before resetting direction (def: <code>Inf</code>)</li><li><code>df</code> Δf values in water-fat imaging (def: <code>[0]</code>) units Hz, e.g., <code>[440]</code> at 3T</li><li><code>relamp</code> relative amplitudes in multi-peak water-fat (def: <code>[1]</code>)</li><li><code>lldl_args::NamedTuple</code> options for <code>lldl</code>, default: <code>(;memory=2)</code></li><li><code>track::Bool</code> if <code>true</code> then track cost and save all iterations (def: <code>false</code>)</li><li><code>chat::Bool = true</code> # <code>@info</code> updates each iteration</li><li><code>chat_iter::Int = 10</code> # print progress report every few iterations.</li></ul><p><strong>Out</strong></p><ul><li><code>fhat</code> final fieldmap estimate in Hz</li><li><code>times (niter+1)</code> wall time for each iteration</li><li><code>out::NamedTuple</code> that contains:<ul><li><code>(xw, xf) (dims)</code> water / fat images if <code>!iszero(df)</code></li><li><code>finit (dims)</code> initial fieldmap</li></ul></li><li>if <code>track == true</code> then <code>out</code> also contains:<ul><li><code>costs (niter+1)</code> (nonconvex) cost for each iteration</li><li><code>fhats (dims, niter+1)</code> fieldmap estimates every iteration</li></ul></li></ul><p>The algorithm is based on the paper: C Y Lin, J A Fessler, &quot;Efficient Regularized Field Map Estimation in 3D MRI&quot;, IEEE TCI 2020 http://doi.org/10.1109/TCI.2020.3031082 http://arxiv.org/abs/2005.08661</p><p>Please cite that paper if you use this code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/MRIFieldmaps.jl/blob/cb68f87669c68a116af1e38f56d90b4c0553d0b8/src/b0map.jl#L12-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIFieldmaps.b0map-Tuple{AbstractVector{&lt;:Number}, AbstractMatrix{&lt;:Complex}, AbstractVector{&lt;:Real}, Union{AbstractVector{&lt;:T}, Tuple{Vararg{var&quot;#s2&quot;, N}} where {N, var&quot;#s2&quot;&lt;:T}} where T, AbstractArray{&lt;:Bool}}" href="#MRIFieldmaps.b0map-Tuple{AbstractVector{&lt;:Number}, AbstractMatrix{&lt;:Complex}, AbstractVector{&lt;:Real}, Union{AbstractVector{&lt;:T}, Tuple{Vararg{var&quot;#s2&quot;, N}} where {N, var&quot;#s2&quot;&lt;:T}} where T, AbstractArray{&lt;:Bool}}"><code>MRIFieldmaps.b0map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">b0map()</code></pre><p>This version expects masked column-like inputs. For expert use only.</p><p><strong>In</strong></p><ul><li><code>finit (np)</code> initial estimate in Hz (<code>np</code> is # of pixels in mask)</li><li><code>zdata (np, ne)</code> <code>ne</code> sets of coil-combined measurements</li><li><code>sos (np)</code> sum-of-squares of coil maps</li><li><code>echotime (ne)</code> vector of <code>ne</code> echo time offsets</li><li><code>mask (N)</code> logical reconstruction mask</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/MRIFieldmaps.jl/blob/cb68f87669c68a116af1e38f56d90b4c0553d0b8/src/b0map.jl#L151-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIFieldmaps.b0model-Union{Tuple{Tx}, Tuple{Tf}, Tuple{Te}, Tuple{D}, Tuple{AbstractArray{Tf, D}, AbstractArray{Tx, D}, Union{Tuple{Vararg{Te, N}} where N, AbstractVector{Te}}}} where {D, Te&lt;:Number, Tf&lt;:Number, Tx&lt;:Number}" href="#MRIFieldmaps.b0model-Union{Tuple{Tx}, Tuple{Tf}, Tuple{Te}, Tuple{D}, Tuple{AbstractArray{Tf, D}, AbstractArray{Tx, D}, Union{Tuple{Vararg{Te, N}} where N, AbstractVector{Te}}}} where {D, Te&lt;:Number, Tf&lt;:Number, Tx&lt;:Number}"><code>MRIFieldmaps.b0model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">b0model(fmap, xw, echotime; kwargs...)</code></pre><p>Compute complex images for B0 field mapping. This function is used mainly for simulation, and for code testing.</p><p>Model: <code>images[j,c,l] = smap[j,c] exp(ı 2π fmap[j] t_l) exp(-relax[j] t_l) x[j,l]</code> where <code>x[j,l] = xw[j] + xf[j] * sum_{p=0}^P α_p exp(ı 2π Δf_p t_l)</code>.</p><p>Field map estimation from multiple (<code>ne ≥ 2</code>) echo-time images,</p><p><strong>In</strong></p><ul><li><code>fmap (dims)</code> fieldmap (in Hz)</li><li><code>xw (dims)</code> water magnetization component</li><li><code>echotime (ne)</code> vector of <code>ne</code> echo time offsets (in sec)</li></ul><p><strong>Options</strong></p><ul><li><code>smap (dims..., nc)</code> complex coil maps, default <code>ones(size(fmap)..., 1)</code></li><li><code>xw (dims)</code> fat magnetization component, default <code>zeros(size(fmap))</code></li><li><code>df</code> Δf values in water-fat imaging (def: <code>[0]</code>) units Hz, e.g., <code>[440]</code> at 3T</li><li><code>relamp</code> relative amplitudes in multi-peak water-fat (def: <code>[1]</code>)</li><li><code>relax (dims)</code> R2* relaxation in same units as <code>fmap</code>, i.e., 1/s</li></ul><p><strong>Out</strong></p><ul><li><code>ydata (dims..., nc, ne)</code> <code>ne</code> sets of complex images for <code>nc</code> coils</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/MRIFieldmaps.jl/blob/cb68f87669c68a116af1e38f56d90b4c0553d0b8/src/b0model.jl#L4-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIFieldmaps.b0scale-Union{Tuple{Te}, Tuple{AbstractArray{&lt;:Complex}, Union{Tuple{Vararg{Te, N}} where N, AbstractVector{Te}}}} where Te&lt;:Number" href="#MRIFieldmaps.b0scale-Union{Tuple{Te}, Tuple{AbstractArray{&lt;:Complex}, Union{Tuple{Vararg{Te, N}} where N, AbstractVector{Te}}}} where Te&lt;:Number"><code>MRIFieldmaps.b0scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(ydata, scalefactor) = b0scale(ydata, echotime; dmax)</code></pre><p>Scale complex images <code>ydata</code> to account for R2* effects and for magnitude variations using <code>median(di)</code> where</p><ul><li><code>ri = sum_j sum_k |y_{ij} y_{ik}|^2 (t_k - t_j)^2</code></li><li><code>di = ri / sum_k |y_{ik}|^2</code></li></ul><p>Only values where <code>di &gt; dmax * maximum(di)</code> affect <code>scalefactor</code>, so it is fine to pass unmasked images here.</p><p>This normalization simplifies regularization parameter selection for regularized B0 fieldmap estimation. See eqn (9) and (15) of Funai &amp; Fessler, Oct. 2008, IEEE T-MI, http://doi.org/10.1109/TMI.2008.923956</p><p><strong>In</strong></p><ul><li><code>ydata (dims..., ne)</code> scan images for <code>ne</code> different echo times</li><li><code>echotime (ne)</code> echo times (units of sec if fieldmap is in Hz)</li></ul><p><strong>Option</strong></p><ul><li><code>dmax::Real</code> threshold for relative <code>di</code> value (default <code>0.1</code>)</li></ul><p><strong>Out</strong></p><ul><li><code>ydata (dims..., ne)</code> scaled scan images</li><li><code>scalefactor = sqrt(median(rj))</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/MRIFieldmaps.jl/blob/cb68f87669c68a116af1e38f56d90b4c0553d0b8/src/b0scale.jl#L15-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIFieldmaps.coil_combine-Tuple{AbstractArray{&lt;:Complex}, AbstractArray{&lt;:Complex}}" href="#MRIFieldmaps.coil_combine-Tuple{AbstractArray{&lt;:Complex}, AbstractArray{&lt;:Complex}}"><code>MRIFieldmaps.coil_combine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zdata, sos = coil_combine(ydata, smap; kwargs...)</code></pre><p>For estimating a B0 field map from complete multi-coil image data, it suffices to first do complex coil combination, while tracking the sum-of-squares <code>sos</code> for proper weighting. Often <code>sos</code> is all 1&#39;s and 0&#39;s.</p><p><strong>In</strong></p><ul><li><code>ydata (dims..., nc, ne)</code> <code>ne ≥ 1</code> sets of complex images for <code>nc ≥ 1</code> coils</li><li><code>smap (dims..., nc)</code> complex coil maps</li></ul><p><strong>Out</strong></p><ul><li><code>zdata (dims..., ne)</code> complex coil combination: <code>sum_c smap[c]&#39; * ydata[c] ./ sos</code></li><li><code>sos (dims...)</code> sum-of-squares: <code>sum_c |smap[c]|^2</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/MRIFieldmaps.jl/blob/cb68f87669c68a116af1e38f56d90b4c0553d0b8/src/combine.jl#L9-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIFieldmaps.spdiff-Tuple{Tuple{Vararg{Int64, N}} where N}" href="#MRIFieldmaps.spdiff-Tuple{Tuple{Vararg{Int64, N}} where N}"><code>MRIFieldmaps.spdiff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spdiff(dims::Dims; order=1, kwargs...)</code></pre><p>Return <code>Vector</code> of <code>length(dims)</code> sparse finite-difference matrices of order <code>order</code>, one for each dimension.</p><p>Typically one will <code>vcat</code> the vector output to make a sparse finite-difference matrix suitable for the <code>vec</code> of a multi-dimensional array.</p><p>The <code>kwargs</code> are passed to <code>spdiff1</code> (for <code>order = 1</code>) or <code>spdiff2</code> (for <code>order = 2</code>). These functions are called once for each dimension. The options are <code>ending</code> and <code>T</code>.</p><p>Examples:</p><ul><li><code>spdiff((4,5,6))[1] == kron(I(6*5), spdiff1(4))</code></li><li><code>spdiff((4,5,6); order=1)[2] == kron(I(6), spdiff1(5), I(4))</code></li><li><code>spdiff((4,5,6); order=2)[3] == kron(spdiff2(6), I(4*5))</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/MRIFieldmaps.jl/blob/cb68f87669c68a116af1e38f56d90b4c0553d0b8/src/spdiff.jl#L12-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIFieldmaps.spdiff1-Tuple{Int64}" href="#MRIFieldmaps.spdiff1-Tuple{Int64}"><code>MRIFieldmaps.spdiff1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spdiff1(n::Int; ending::Symbol = :remove, T::DataType = Int32)</code></pre><p>Sparse <code>n × n</code> matrix for 1st-order finite differences.</p><p><strong>Option</strong></p><ul><li><code>T</code> element type, default <code>Int32</code> to save memory</li><li><code>ending</code><ul><li><code>:remove</code> (default) remove first difference</li><li><code>:zero</code> keep first row, akin to zero boundary conditions</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/MRIFieldmaps.jl/blob/cb68f87669c68a116af1e38f56d90b4c0553d0b8/src/spdiff1.jl#L10-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIFieldmaps.spdiff2-Tuple{Int64}" href="#MRIFieldmaps.spdiff2-Tuple{Int64}"><code>MRIFieldmaps.spdiff2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spdiff2(n::Int; ending::Symbol = :remove, T::DataType = Int32)</code></pre><p>Sparse <code>n × n</code> matrix for 2nd-order finite differences.</p><p><strong>Option</strong></p><ul><li><code>T</code> element type, default <code>Int32</code> to save memory</li><li><code>ending</code><ul><li><code>:remove</code> (default) remove first and last finite difference</li><li><code>:zero</code> keep first and last rows, akin to zero boundary conditions</li><li><code>:first</code> use 1st-order finite differences for first and last rows</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MagneticResonanceImaging/MRIFieldmaps.jl/blob/cb68f87669c68a116af1e38f56d90b4c0553d0b8/src/spdiff2.jl#L10-L22">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../generated/examples/01-overview/">MRIFieldmaps overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 25 November 2022 18:30">Friday 25 November 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
