var documenterSearchIndex = {"docs":
[{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"EditURL = \"https://github.com/MagneticResonanceImaging/MRIfieldmaps.jl/blob/main/docs/lit/examples/docs/lit/examples/02-b0map.jl\"","category":"page"},{"location":"generated/examples/02-b0map/#b0map","page":"B0 field map","title":"B0 field map","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"This page illustrates regularized B0 3D field map estimation from multi-echo multi-coil MRI images using the Julia package MRIfieldmaps.","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"This page was generated from a single Julia file: 02-b0map.jl.","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"In any such Julia documentation, you can access the source code using the \"Edit on GitHub\" link in the top right.","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"The corresponding notebook can be viewed in nbviewer here: 02-b0map.ipynb, and opened in binder here: 02-b0map.ipynb.","category":"page"},{"location":"generated/examples/02-b0map/#Setup","page":"B0 field map","title":"Setup","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Packages needed here.","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"using MRIfieldmaps: b0map, b0model, b0init, b0scale\nusing MIRTjim: jim, prompt; jim(:prompt, true)\nusing MAT: matread\nimport Downloads # todo: use Fetch or DataDeps?\nusing MIRT: ir_mri_sensemap_sim\nusing Random: seed!\nusing StatsBase: mean\nusing Unitful: s\nusing Plots; default(markerstrokecolor=:auto, label=\"\")","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"The following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"generated/examples/02-b0map/#Overview","page":"B0 field map","title":"Overview","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"This example is based on the simulation example from the repo that reproduces Experiment A and Figs. 3 & 4 in the paper \"Efficient Regularized Field Map Estimation in 3D MRI\" by Claire Lin and Jeff Fessler, 2020","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"This example uses units (seconds) to illustrate that capability of the package, but units are not required.","category":"page"},{"location":"generated/examples/02-b0map/#Read-data","page":"B0 field map","title":"Read data","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"if !@isdefined(data)\n    repo = \"https://github.com/ClaireYLin/regularized-field-map-estimation\"\n    dataurl = \"$repo/blob/main/data/input_object_40sl_3d_epi_snr40.mat?raw=true\"\n    data = matread(Downloads.download(dataurl))\nend;\nnothing #hide","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Extract arrays used in simulation","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"if !@isdefined(ftrue)\n    zp = 1:40 # choose subset of slices\n    mask = data[\"maskR\"][:,:,zp]\n    ftrue = (data[\"in_obj\"][\"ztrue\"][:,:,zp] .* mask) / 2π / 1s # Hz\n    ftrue .*= mask # true field map (in Hz) for simulation\n    mag = data[\"in_obj\"][\"xtrue\"] .* mask # true baseline magnitude\n    (nx,ny,nz) = size(mag)\n    clim = (-100,100) # display range in Hz\n    jim(ftrue .* mask; clim, title=\"True fieldmap in Hz (Fig 3d)\")\nend","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Function for computing RMSE within the mask","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"frmse = f -> round(sqrt(sum(abs2, (f - ftrue)[mask]) / count(mask)) * s, digits=1) / s;\nnothing #hide","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Parameters for data generation","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"echotime = [0, 2, 10] * 1f-3 * 1s # echo times in sec\ntrue_thresh = 0.05 # threshold of the true object for determining reconstruction mask\nsnr = 24 # noise level in dB\nne = length(echotime)\nnc = 4; # number of coils in simulation\nnothing #hide","category":"page"},{"location":"generated/examples/02-b0map/#Simulate-sensitivity-maps","page":"B0 field map","title":"Simulate sensitivity maps","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"(rcoil=100 to match matlab default). todo: polynomial approximation?","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"if !@isdefined(smap)\n    smap = ir_mri_sensemap_sim(; dims=(nx, ny, nz), ncoil=nc, rcoil=100)\n    div0 = (x::Number,y::Number) -> iszero(y) ? 0 : x/y\n    smap ./= sqrt.(sum(abs2, smap; dims=4)) # normalize by SSoS\n    jim(smap, \"|smap|\"; ncol=nz÷2)\nend","category":"page"},{"location":"generated/examples/02-b0map/#Generate-simulated-image-data","page":"B0 field map","title":"Generate simulated image data","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"This is the multi-coil version, for multiple echo times, with additive complex Gaussian noise.","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Because b0model uses cis(+phase), the resulting fieldmap may be the negative of the needed for your scanner!","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"ytrue = b0model(ftrue, mag, echotime; smap)\nseed!(0) # matlab and julia will differ","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"compute the noise_std to get the desired SNR","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"image_power = 10 * log10(sum(abs2, mag) / (nx*ny*nz)) # in dB\nnoise_power = image_power - snr\nnoise_std = sqrt(10^(noise_power/10)) / 2 # because complex\nynoise = Float32(noise_std) * randn(ComplexF32, size(ytrue))\nydata = ytrue + ynoise; # add the noise to the data\nnothing #hide","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Compute the SNR for each echo time to verify","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"tmp = [sum(abs2, ytrue[:,:,:,:,i]) / sum(abs2, ynoise[:,:,:,:,i]) for i in 1:ne]\ndatasnr = 10 * log10.(tmp)","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Show data magnitude","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"jim(ydata[:,:,:,:,end], \"|data|\"; ncol=nz÷2)","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Coil combine image data and scale","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"if !@isdefined(yik_sos)\n    yik_sos = sum(conj(smap) .* ydata; dims=4) # coil combine\n    yik_sos = yik_sos[:,:,:,1,:] # (dims..., ne)\n    jim(yik_sos, \"|data sos|\"; ncol=nz÷2)\n    (yik_sos_scaled, scale) = b0scale(yik_sos, echotime) # todo\n    jim(yik_sos_scaled, \"|scaled data|\"; ncol=nz÷2)\nend","category":"page"},{"location":"generated/examples/02-b0map/#Initialize-fieldmap","page":"B0 field map","title":"Initialize fieldmap","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Compute finit using phase difference of first two echo times (no smoothing):","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"finit = b0init(ydata, echotime; smap)\njim(finit .* mask; clim, title=\"Initial fieldmap in Hz (Fig 3b)\",\n    xlabel = \"RMSE = $(frmse(finit)) Hz\")","category":"page"},{"location":"generated/examples/02-b0map/#Run-NCG","page":"B0 field map","title":"Run NCG","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Run each algorithm twice; once to track rmse and costs, once for timing","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"yik_scale = ydata / scale\nfmap_run = (niter, precon, track; kwargs...) ->\n    b0map(yik_scale, echotime; smap, mask,\n       order=1, l2b=-4, gamma_type=:PR, niter, precon, track, kwargs...)\n\nfunction runner(niter, precon; kwargs...)\n    (fmap, _, out) = fmap_run(niter, precon, true; kwargs...) # tracking run\n    (_, times, _) = fmap_run(niter, precon, false; kwargs...) # timing run\n    return (fmap, out.fhats, out.costs, times)\nend;\nnothing #hide","category":"page"},{"location":"generated/examples/02-b0map/#.-NCG:-no-precon","page":"B0 field map","title":"2. NCG: no precon","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"if !@isdefined(fmap_cg_n)\n    niter_cg_n = 50\n    (fmap_cg_n, fhat_cg_n, cost_cg_n, time_cg_n) = runner(niter_cg_n, :I)\n\n    pcost = plot(time_cg_n, cost_cg_n, marker=:circle, label=\"NCG-MLS\");\n    pi_cn = jim(fmap_cg_n, \"CG:I\"; clim,\n        xlabel = \"RMSE = $(frmse(fmap_cg_n)) Hz\")\nend","category":"page"},{"location":"generated/examples/02-b0map/#.-NCG:-diagonal-preconditioner","page":"B0 field map","title":"3. NCG: diagonal preconditioner","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"if !@isdefined(fmap_cg_d)\n    niter_cg_d = 40\n    (fmap_cg_d, fhat_cg_d, cost_cg_d, time_cg_d) = runner(niter_cg_d, :diag)\n\n    plot!(pcost, time_cg_d, cost_cg_d, marker=:square, label=\"NCG-MLS-D\")\n    pi_cd = jim(fmap_cg_d, \"CG:diag\"; clim,\n        xlabel = \"RMSE = $(frmse(fmap_cg_d)) Hz\")\nend","category":"page"},{"location":"generated/examples/02-b0map/#.-NCG:-Cholesky-preconditioner","page":"B0 field map","title":"4. NCG: Cholesky preconditioner","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"(This one may use too much memory for larger images.)","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"if !@isdefined(fmap_cg_c)\n    niter_cg_c = 3\n    (fmap_cg_c, fhat_cg_c, cost_cg_c, time_cg_c) = runner(niter_cg_c, :chol)\n\n    plot!(pcost, time_cg_c, cost_cg_c, marker=:square, label=\"NCG-MLS-C\")\n    pi_cc = jim(fmap_cg_c, \"CG:chol\"; clim,\n        xlabel = \"RMSE = $(frmse(fmap_cg_c)) Hz\")\nend","category":"page"},{"location":"generated/examples/02-b0map/#.-NCG:-Incomplete-Cholesky-preconditioner","page":"B0 field map","title":"5. NCG: Incomplete Cholesky preconditioner","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"if !@isdefined(fmap_cg_i)\n    niter_cg_i = 14\n    (fmap_cg_i, fhat_cg_i, cost_cg_i, time_cg_i) =\n        runner(niter_cg_i, :ichol; lldl_args = (; memory=20, droptol=0))\n\n    plot!(pcost, time_cg_i, cost_cg_i, marker=:square, label=\"NCG-MLS-IC\",\n        xlabel = \"time [s]\", ylabel=\"cost\")\n    pi_ci = jim(fmap_cg_i, \"CG:ichol\"; clim,\n        xlabel = \"RMSE = $(frmse(fmap_cg_i)) Hz\")\nend","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Compare final RMSE values","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"frmse.((ftrue, finit, fmap_cg_n, fmap_cg_d, fmap_cg_c, fmap_cg_i))","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Plot RMSE vs wall time","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"prmse = plot(xlabel = \"time [s]\", ylabel=\"RMSE [Hz]\")\nfun = (time, fhat, label) ->\n    plot!(prmse, time, frmse.(eachslice(fhat; dims=4)); label, marker=:circ)\nfun(time_cg_n, fhat_cg_n, \"None\")\nfun(time_cg_d, fhat_cg_d, \"Diag\")\nfun(time_cg_c, fhat_cg_c, \"Chol\")\nfun(time_cg_i, fhat_cg_i, \"IC\")","category":"page"},{"location":"generated/examples/02-b0map/#Discussion","page":"B0 field map","title":"Discussion","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"That final figure is similar to Fig. 4 of the 2020 Lin&Fessler paper, after correcting that figure for a factor of π.","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"This figure was generated in github's cloud, where the servers are busily multi-tasking, so the compute times per iteration can vary widely between iterations and runs.","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Nevertheless, it is interesting that in this Julia implementation the diagonal preconditioner seems to be as effective as the incomplete Cholesky preconditioner.","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"This page was generated using Literate.jl.","category":"page"},{"location":"methods/#Methods-list","page":"Methods","title":"Methods list","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"","category":"page"},{"location":"methods/#Methods-usage","page":"Methods","title":"Methods usage","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Modules = [MRIfieldmaps]","category":"page"},{"location":"methods/#MRIfieldmaps.MRIfieldmaps","page":"Methods","title":"MRIfieldmaps.MRIfieldmaps","text":"MRIfieldmaps\n\nModule MRIfieldmaps exports methods for fieldmap estimation.\n\n\n\n\n\n","category":"module"},{"location":"methods/#MRIfieldmaps.Echotime","page":"Methods","title":"MRIfieldmaps.Echotime","text":"Echotime{T} = Union{AbstractVector{<:T}, NTuple{N,<:T} where N}\n\nThe echo times can be a vector or a Tuple.\n\n\n\n\n\n","category":"type"},{"location":"methods/#MRIfieldmaps.RealU","page":"Methods","title":"MRIfieldmaps.RealU","text":"RealU\n\nA data type that is just Number but is to be thought of as Union{Real, Unitful} without needing a dependence on the Unitful package.\n\n\n\n\n\n","category":"type"},{"location":"methods/#MRIfieldmaps.b0init-Union{Tuple{Te}, Tuple{D}, Tuple{AbstractArray{<:Complex, D}, Union{AbstractVector{<:Te}, Tuple{Vararg{var\"#s2\", N}} where {N, var\"#s2\"<:Te}}}} where {D, Te<:Number}","page":"Methods","title":"MRIfieldmaps.b0init","text":"finit = b0init(ydata, echotime; kwargs...)\n\nClassic B0 field map estimation based on the phase difference of complex images at two different echo times. If sensitivity maps (smap) are provided, complex coil combination is done first. This code works with images of arbitrary dimensions (2D, 3D, etc.), and with multiple coils.\n\nIn the usual case where echotime has units of seconds, the returned B0 fieldmap will have units of Hz.\n\nIf df is nonempty (which always holds for water-fat case), then perform discrete maximum-likelihood estimation using fdict.\n\nIn\n\nydata (dims..., nc, ne) ne sets of complex images for nc ≥ 1 coils\nechotime (ne) vector of ne ≥ 2 echo times (only first 2 are used)\n\nOptions\n\nsmap (dims..., nc) complex coil maps; default ones\nthreshold set finit values where |y1| < threshold * max(|y1|)  to the mean of the \"good\" values where |y1| ≥ threshold * max(|y1|).  default: 0.1\n\nOptions for water-fat case:\n\ndf Δf values in water-fat imaging (def: []) units Hz, e.g., [440] at 3T\nrelamp relative amplitudes in multi-species water-fat (def: [])\nfband frequency bandwidth for fdict; defaultfloor(1 / minimum(echo time spacing))`\nnf number of discrete frequencies to try; default 1+floor(fband) so ≈1Hz spacing\nfdict \"dictionary\" of discrete frequency values to try; default LinRange(-1/2,1/2,nf) * fband\n\nOut\n\nfinit initial B0 fieldmap estimate in Hz\n\n\n\n\n\n","category":"method"},{"location":"methods/#MRIfieldmaps.b0map","page":"Methods","title":"MRIfieldmaps.b0map","text":"(fhat, times, out) = b0map(ydata, echotime; kwargs...)\n\nField map estimation from multiple (ne ≥ 2) echo-time images, using preconditioned nonlinear CG (NCG) with a monotonic line search. This code works with images of arbitrary dimensions (2D, 3D, etc.), and with multiple coils.\n\nCaution: single coil data must be reshaped to size (dims..., 1, ne).\n\nThe cost function for the single-coil case is: cost(w) = ∑_{j=1}^{#voxel} ∑_{m=1}^ne ∑_{n=1}^ne     |y_{mj} y_{nj}| wj (1 - cos(w_j * (t_m - t_n) + ∠y_{ni} - ∠y_{mj})) + R(w) where t_n denotes the echo time of the nth scan and R(w) = 0.5 * | C * w |^2 is a quadratic roughness regularizer based on 1st-order or 2nd-order finite differences. See the documentation for the general multi-coil case.\n\nThe initial field map finit and output fhat are field maps in Hz, but internally the code works with ω = 2π f (rad/s).\n\nIn\n\nydata (dims..., nc, ne) ne sets of complex images for nc ≥ 1 coils\nechotime::Echotime (ne ≥ 2) echo time offsets (in seconds)\n\nOptions\n\nfinit (dims) initial fieldmap estimate (in Hz); default from b0init()\nsmap (dims..., nc) complex coil maps; default ones(size(ydata)[1:end-1])\nmask (dims...) logical reconstruction mask; default: trues(size(finit))\nninner # of inner iterations for monotonic line search default: 3 inner iterations\nb0init_args::NamedTuple = (;) options for b0init, such as threshold\nniter # of outer iterations (def: 30)\norder order of the finite-difference matrix (def: 2)\nl2b log2 of regularization parameter (def: -6)\ngamma_type CG direction:\n:PR = Polak-Ribiere (default)\n:FR = Fletcher-Reeves\nprecon Preconditioner:\n:I (nothing)\n:diag\n:chol may require too much memory\n:ichol (default)\nreset # of iterations before resetting direction (def: Inf)\ndf Δf values in water-fat imaging (def: [0]) units Hz, e.g., [440] at 3T\nrelamp relative amplitudes in multi-peak water-fat (def: [1])\nlldl_args::NamedTuple options for lldl, default: (;memory=2)\ntrack::Bool if true then track cost and save all iterations (def: false)\nchat::Bool = true # @info updates each iteration\nchat_iter::Int = 10 # print progress report every few iterations.\n\nOut\n\nfhat final fieldmap estimate in Hz\ntimes (niter+1) wall time for each iteration\nout::NamedTuple that contains:\n(xw, xf) (dims) water / fat images if !iszero(df)\nfinit (dims) initial fieldmap\nif track == true then out also contains:\ncosts (niter+1) (nonconvex) cost for each iteration\nfhats (dims, niter+1) fieldmap estimates every iteration\n\nThe algorithm is based on the paper: C Y Lin, J A Fessler, \"Efficient Regularized Field Map Estimation in 3D MRI\", IEEE TCI 2020 http://doi.org/10.1109/TCI.2020.3031082 http://arxiv.org/abs/2005.08661\n\nPlease cite that paper if you use this code.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MRIfieldmaps.b0map-Tuple{AbstractVector{<:Number}, AbstractMatrix{<:Complex}, AbstractVector{<:Real}, Union{AbstractVector{<:T}, Tuple{Vararg{var\"#s2\", N}} where {N, var\"#s2\"<:T}} where T, AbstractArray{<:Bool}}","page":"Methods","title":"MRIfieldmaps.b0map","text":"b0map()\n\nThis version expects masked column-like inputs. For expert use only.\n\nIn\n\nfinit (np) initial estimate in Hz (np is # of pixels in mask)\nzdata (np, ne) ne sets of coil-combined measurements\nsos (np) sum-of-squares of coil maps\nechotime (ne) vector of ne echo time offsets\nmask (N) logical reconstruction mask\n\n\n\n\n\n","category":"method"},{"location":"methods/#MRIfieldmaps.b0model-Union{Tuple{Tx}, Tuple{Tf}, Tuple{Te}, Tuple{D}, Tuple{AbstractArray{Tf, D}, AbstractArray{Tx, D}, Union{Tuple{Vararg{Te, N}} where N, AbstractVector{Te}}}} where {D, Te<:Number, Tf<:Number, Tx<:Number}","page":"Methods","title":"MRIfieldmaps.b0model","text":"b0model(fmap, xw, echotime; kwargs...)\n\nCompute complex images for B0 field mapping. This function is used mainly for simulation, and for code testing.\n\nModel: images[j,c,l] = smap[j,c] exp(ı 2π fmap[j] t_l) exp(-relax[j] t_l) x[j,l] where x[j,l] = xw[j] + xf[j] * sum_{p=0}^P α_p exp(ı 2π Δf_p t_l).\n\nField map estimation from multiple (ne ≥ 2) echo-time images,\n\nIn\n\nfmap (dims) fieldmap (in Hz)\nxw (dims) water magnetization component\nechotime (ne) vector of ne echo time offsets (in sec)\n\nOptions\n\nsmap (dims..., nc) complex coil maps, default ones(size(fmap)..., 1)\nxw (dims) fat magnetization component, default zeros(size(fmap))\ndf Δf values in water-fat imaging (def: [0]) units Hz, e.g., [440] at 3T\nrelamp relative amplitudes in multi-peak water-fat (def: [1])\nrelax (dims) R2* relaxation in same units as fmap, i.e., 1/s\n\nOut\n\nydata (dims..., nc, ne) ne sets of complex images for nc coils\n\n\n\n\n\n","category":"method"},{"location":"methods/#MRIfieldmaps.b0scale-Union{Tuple{Te}, Tuple{AbstractArray{<:Complex}, Union{Tuple{Vararg{Te, N}} where N, AbstractVector{Te}}}} where Te<:Number","page":"Methods","title":"MRIfieldmaps.b0scale","text":"(ydata, scalefactor) = b0scale(ydata, echotime; dmax)\n\nScale complex images ydata to account for R2* effects and for magnitude variations using median(di) where\n\nri = sum_j sum_k |y_{ij} y_{ik}|^2 (t_k - t_j)^2\ndi = ri / sum_k |y_{ik}|^2\n\nOnly values where di > dmax * maximum(di) affect scalefactor, so it is fine to pass unmasked images here.\n\nThis normalization simplifies regularization parameter selection for regularized B0 fieldmap estimation. See eqn (9) and (15) of Funai & Fessler, Oct. 2008, IEEE T-MI, http://doi.org/10.1109/TMI.2008.923956\n\nIn\n\nydata (dims..., ne) scan images for ne different echo times\nechotime (ne) echo times (units of sec if fieldmap is in Hz)\n\nOption\n\ndmax::Real threshold for relative di value (default 0.1)\n\nOut\n\nydata (dims..., ne) scaled scan images\nscalefactor = sqrt(median(rj))\n\n\n\n\n\n","category":"method"},{"location":"methods/#MRIfieldmaps.coil_combine-Tuple{AbstractArray{<:Complex}, AbstractArray{<:Complex}}","page":"Methods","title":"MRIfieldmaps.coil_combine","text":"zdata, sos = coil_combine(ydata, smap; kwargs...)\n\nFor estimating a B0 field map from complete multi-coil image data, it suffices to first do complex coil combination, while tracking the sum-of-squares sos for proper weighting. Often sos is all 1's and 0's.\n\nIn\n\nydata (dims..., nc, ne) ne ≥ 1 sets of complex images for nc ≥ 1 coils\nsmap (dims..., nc) complex coil maps\n\nOut\n\nzdata (dims..., ne) complex coil combination: sum_c smap[c]' * ydata[c] ./ sos\nsos (dims...) sum-of-squares: sum_c |smap[c]|^2\n\n\n\n\n\n","category":"method"},{"location":"methods/#MRIfieldmaps.spdiff-Tuple{Tuple{Vararg{Int64, N}} where N}","page":"Methods","title":"MRIfieldmaps.spdiff","text":"spdiff(dims::Dims; order=1, kwargs...)\n\nReturn Vector of length(dims) sparse finite-difference matrices of order order, one for each dimension.\n\nTypically one will vcat the vector output to make a sparse finite-difference matrix suitable for the vec of a multi-dimensional array.\n\nThe kwargs are passed to spdiff1 (for order = 1) or spdiff2 (for order = 2). These functions are called once for each dimension. The options are ending and T.\n\nExamples:\n\nspdiff((4,5,6))[1] == kron(I(6*5), spdiff1(4))\nspdiff((4,5,6); order=1)[2] == kron(I(6), spdiff1(5), I(4))\nspdiff((4,5,6); order=2)[3] == kron(spdiff2(6), I(4*5))\n\n\n\n\n\n","category":"method"},{"location":"methods/#MRIfieldmaps.spdiff1-Tuple{Int64}","page":"Methods","title":"MRIfieldmaps.spdiff1","text":"spdiff1(n::Int; ending::Symbol = :remove, T::DataType = Int32)\n\nSparse n × n matrix for 1st-order finite differences.\n\nOption\n\nT element type, default Int32 to save memory\nending\n:remove (default) remove first difference\n:zero keep first row, akin to zero boundary conditions\n\n\n\n\n\n","category":"method"},{"location":"methods/#MRIfieldmaps.spdiff2-Tuple{Int64}","page":"Methods","title":"MRIfieldmaps.spdiff2","text":"spdiff2(n::Int; ending::Symbol = :remove, T::DataType = Int32)\n\nSparse n × n matrix for 2nd-order finite differences.\n\nOption\n\nT element type, default Int32 to save memory\nending\n:remove (default) remove first and last finite difference\n:zero keep first and last rows, akin to zero boundary conditions\n:first use 1st-order finite differences for first and last rows\n\n\n\n\n\n","category":"method"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"EditURL = \"https://github.com/MagneticResonanceImaging/MRIfieldmaps.jl/blob/main/docs/lit/examples/docs/lit/examples/01-overview.jl\"","category":"page"},{"location":"generated/examples/01-overview/#overview","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"This page summarizes the Julia package MRIfieldmaps.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"This page was generated from a single Julia file: 01-overview.jl.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"In any such Julia documentation, you can access the source code using the \"Edit on GitHub\" link in the top right.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"The corresponding notebook can be viewed in nbviewer here: 01-overview.ipynb, and opened in binder here: 01-overview.ipynb.","category":"page"},{"location":"generated/examples/01-overview/#Setup","page":"MRIfieldmaps overview","title":"Setup","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"Packages needed here. Use Pkg.add as illustrated here when using a package for the first time.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"using MRIfieldmaps: spdiff\nusing MIRTjim: jim, prompt; jim(:prompt, true)\nusing InteractiveUtils: versioninfo","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"The following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"generated/examples/01-overview/#Overview","page":"MRIfieldmaps overview","title":"Overview","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"This package provides algorithms for estimating fieldmaps in MRI. Currently it supports B0 map estimation. A future extension could support B1+ map estimation.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"This page just discusses the regularization; other examples illustrate specific fieldmap estimators.","category":"page"},{"location":"generated/examples/01-overview/#Regularization","page":"MRIfieldmaps overview","title":"Regularization","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"Some methods in this package use sparse matrices to perform finite-difference operations. Those operations could be performed with a LinearMap based on diff, but the fastest algorithms here use preconditioning based on incomplete Cholesky factorization of a Hessian matrix, and such factorization is supported for sparse matrices, but probably not for general linear maps.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"It may be helpful to visualize these sparse matrices.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"Here are 1D 1st-order and 2nd-order finite differences.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"D1 = spdiff((8,); order=1)[1]\nD2 = spdiff((8,); order=2)[1]\nclim = (-1, 2)\ncolor = :cividis\njim(\n jim(Matrix(D1)', \"1st-order\"; color, clim, prompt=false),\n jim(Matrix(D2)', \"2nd-order\"; color, clim, prompt=false),\n)","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"There are other boundary conditions available:","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"D1z = spdiff((8,); order=1, ending=:zero)[1]\nD2z = spdiff((8,); order=2, ending=:zero)[1]\nD2f = spdiff((8,); order=2, ending=:first)[1]\njim(\n jim(Matrix(D1z)', \"1st-order, zero ends\"; color, clim, prompt=false),\n jim(Matrix(D2z)', \"2nd-order, zero ends\"; color, clim, prompt=false),\n jim(Matrix(D2f)', \"2nd-order, 1st ends\"; color, clim, prompt=false),\n ; layout = (3,1),\n)","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"For multi-dimensional arrays, regularizers need finite-differences along each dimension, and these are constructed with Kronecker products and are applied to the vec of an array.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"dims = (9,8)\nd1 = spdiff(dims; order=1)\nd2 = spdiff(dims; order=2)\njim(\n jim(Matrix(d1[1])', \"1st-order, 1st dim\"; color, clim, prompt=false),\n jim(Matrix(d1[2])', \"1st-order, 2nd dim\"; color, clim, prompt=false),\n jim(Matrix(d2[1])', \"2nd-order, 1st dim\"; color, clim, prompt=false),\n jim(Matrix(d2[2])', \"2nd-order, 2nd dim\"; color, clim, prompt=false),\n)","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"Here is an illustration of applying these finite-difference matrices to a simple test phantom. Note the use of vec and reshape for display.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"dims = (40,30)\nx = LinRange(-1, 1, dims[1])\ny = LinRange(-1, 1, dims[2])\nphantom = @. abs(x) + abs(y') < 0.5\nsp = spdiff(dims; order=1)\nd1 = reshape(sp[1] * vec(phantom), dims)\nd2 = reshape(sp[2] * vec(phantom), dims)\njim(\n jim(x, y, phantom, \"Test image\"),\n jim(x, y, d1, \"1st dim differences\"),\n jim(x, y, d2, \"2nd dim differences\"),\n)","category":"page"},{"location":"generated/examples/01-overview/#Support-mask","page":"MRIfieldmaps overview","title":"Support mask","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"Often we want to estimate a fieldmap over some spatial support \"mask\" that is smaller than the entire image, e.g., only in voxels where the signal is sufficiently large. See the ImageGeoms.jl documentation about the related embed and maskit operations.","category":"page"},{"location":"generated/examples/01-overview/#Reproducibility","page":"MRIfieldmaps overview","title":"Reproducibility","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"This page was generated with the following version of Julia:","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"io = IOBuffer(); versioninfo(io); split(String(take!(io)), '\\n')","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"And with the following package versions","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"import Pkg; Pkg.status()","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIfieldmaps overview","title":"MRIfieldmaps overview","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MRIfieldmaps","category":"page"},{"location":"#MRIfieldmaps.jl-Documentation","page":"Home","title":"MRIfieldmaps.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package (MRIfieldmaps) provides tools for estimating fieldmaps in MRI.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the \"Examples\" for details.","category":"page"}]
}
