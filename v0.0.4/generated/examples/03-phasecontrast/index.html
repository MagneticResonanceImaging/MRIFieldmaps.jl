<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Phase contrast B0 mapping · MRIFieldmaps.jl</title><meta name="title" content="Phase contrast B0 mapping · MRIFieldmaps.jl"/><meta property="og:title" content="Phase contrast B0 mapping · MRIFieldmaps.jl"/><meta property="twitter:title" content="Phase contrast B0 mapping · MRIFieldmaps.jl"/><meta name="description" content="Documentation for MRIFieldmaps.jl."/><meta property="og:description" content="Documentation for MRIFieldmaps.jl."/><meta property="twitter:description" content="Documentation for MRIFieldmaps.jl."/><meta property="og:url" content="https://MagneticResonanceImaging.github.io/MRIFieldmaps.jl/stable/generated/examples/03-phasecontrast/"/><meta property="twitter:url" content="https://MagneticResonanceImaging.github.io/MRIFieldmaps.jl/stable/generated/examples/03-phasecontrast/"/><link rel="canonical" href="https://MagneticResonanceImaging.github.io/MRIFieldmaps.jl/stable/generated/examples/03-phasecontrast/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">MRIFieldmaps.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../../methods/">Methods</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../01-overview/">MRIFieldmaps overview</a></li><li><a class="tocitem" href="../02-b0map/">B0 field map</a></li><li class="is-active"><a class="tocitem" href>Phase contrast B0 mapping</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Get-simulated-data"><span>Get simulated data</span></a></li><li><a class="tocitem" href="#Estimate-B0"><span>Estimate B0</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Phase contrast B0 mapping</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Phase contrast B0 mapping</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MagneticResonanceImaging/MRIFieldmaps.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MagneticResonanceImaging/MRIFieldmaps.jl/blob/main/docs/lit/examples/03-phasecontrast.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="03-phasecontrast"><a class="docs-heading-anchor" href="#03-phasecontrast">Phase contrast B0 mapping</a><a id="03-phasecontrast-1"></a><a class="docs-heading-anchor-permalink" href="#03-phasecontrast" title="Permalink"></a></h1><p>This page illustrates regularized B0 3D field map estimation from multi-echo, multi-coil MRI images using the Julia package <a href="https://github.com/MagneticResonanceImaging/MRIFieldmaps.jl"><code>MRIFieldmaps</code></a>. In this case, we assume we do not have access to coil sensitivity maps. Instead of using those maps for coil combination, we will use a phase contrast-based approach.</p><p>This page comes from a single Julia file: <a href="https://github.com/MagneticResonanceImaging/MRIFieldmaps.jl/blob/main/docs/lit/examples/03-phasecontrast.jl"><code>03-phasecontrast.jl</code></a>.</p><p>You can access the source code for such Julia documentation using the &#39;Edit on GitHub&#39; link in the top right. You can view the corresponding notebook in <a href="https://nbviewer.org/">nbviewer</a> here: <a href="https://nbviewer.org/github/MagneticResonanceImaging/MRIFieldmaps.jl/tree/gh-pages/dev/generated/examples/03-phasecontrast.ipynb"><code>03-phasecontrast.ipynb</code></a>, or open it in <a href="https://mybinder.org/">binder</a> here: <a href="https://mybinder.org/v2/gh/MagneticResonanceImaging/MRIFieldmaps.jl/gh-pages?filepath=dev/generated/examples/03-phasecontrast.ipynb"><code>03-phasecontrast.ipynb</code></a>.</p><h3 id="Setup"><a class="docs-heading-anchor" href="#Setup">Setup</a><a id="Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Setup" title="Permalink"></a></h3><p>Packages needed here.</p><pre><code class="language-julia hljs">using MRIFieldmaps: b0map, phasecontrast
using MIRTjim: jim, prompt; jim(:prompt, true)
using Random: seed!
using Unitful: s, ms, Hz</code></pre><p>The following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.</p><pre><code class="language-julia hljs">isinteractive() ? jim(:prompt, true) : prompt(:draw);</code></pre><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>When estimating B0 field maps from multi-coil data, the images first can be coil-combined in a way that preserves image phase. Ideally, one has access to coil sensitivity maps that can be used for the coil combination. However, coil sensitivity maps are not always available (e.g., for B0 shimming). One way of coil combining the images without coil sensitivity maps is to pretend all the coils are uniformly sensitive across the object (i.e., assume the sensitivity maps are uniformly equal to 1). Alternatively, one can effectively use the multi-coil images themselves to glean information about the coil sensitivies and coil combine the images using a phase contrast-based approach.</p><p>We now review the B0 mapping procedure so that we can then understand how the choice of coil combination scheme influences the estimated field map. For the case we are considering, where coil combination is done as a preprocessing step, the regularized, iterative B0 mapping procedure seeks to minimize</p><p class="math-container">\[\Psi(\mathbf{\omega}) = \Phi(\mathbf{\omega}) + \frac{\beta}{2} \|\mathbf{C} \mathbf{\omega}\|_2^2,\]</p><p>where <span>$\mathbf{\omega}$</span> is the field map, <span>$\Phi(\mathbf{\omega})$</span> computes the data fit term, <span>$\mathbf{C}$</span> is a finite difference operator to encourage spatial smoothness of the field map, and <span>$\beta$</span> is a regularization parameter. The data fit term is given by</p><p class="math-container">\[\Phi(\mathbf{\omega}) = \sum_{j = 1}^{N_{\mathrm{v}}} \sum_{m, n = 1}^{N_{\mathrm{e}}} \phi_{mnj}(\omega_j),\]</p><p>where <span>$N_{\mathrm{v}}$</span> is the number of image voxels, <span>$N_{\mathrm{e}}$</span> is the number of echoes, and</p><p class="math-container">\[\phi_{mnj}(\omega_j) = |r_{mnj}| [1 - \cos(\angle r_{mnj} + \omega_j (t_m - t_n))].\]</p><p>Here, <span>$t_m - t_n$</span> represents the echo time difference between the <span>$m$</span>th and <span>$n$</span>th echoes, and</p><p class="math-container">\[r_{mnj} = \frac{1}{N_{\mathrm{e}}} z_{mj}^{*} z_{nj},\]</p><p>where <span>$z_{nj}$</span> is the (coil-combined) image value for echo <span>$n$</span> at voxel <span>$j$</span>, and <span>$(\cdot)^{*}$</span> denotes complex conjugate.</p><p>We now consider what <span>$z_{nj}$</span> looks like for the coil combination schemes discussed.</p><ol><li><em>Coil combination using coil sensitivities:</em> In this case, we first compute the sum-of-squares of the sensitivity maps:<p class="math-container">\[v_j = \sum_{c = 1}^{N_{\mathrm{c}}} |s_{cj}|^2,\]</p>where <span>$s_{cj}$</span> is the coil sensitivity of coil <span>$c$</span> at voxel <span>$j$</span>, and <span>$N_{\mathrm{c}}$</span> is the number of coils. We then use the sensitivity maps for the coil combination:<p class="math-container">\[z_{nj} = \frac{1}{\sqrt{v_j}} \sum_{c = 1}^{N_{\mathrm{c}}} s_{cj}^{*} y_{cnj},\]</p>where <span>$y_{cnj}$</span> is the image data for coil <span>$c$</span> of echo <span>$n$</span> at voxel <span>$j$</span>.</li><li><em>Taking coil sensitivities to be uniformly equal to 1:</em> In this case, <span>$s_{cj} = 1 \, \forall c, j$</span>, so <span>$v_j = N_{\mathrm{c}}$</span> and<p class="math-container">\[z_{nj} = \frac{1}{\sqrt{N_{\mathrm{c}}}} \sum_{c = 1}^{N_{\mathrm{c}}} y_{cnj}.\]</p></li><li><em>Phase contrast-based approach:</em> In this case, we first coil combine the first echo image by taking the sum-of-squares across coils:<p class="math-container">\[v_j = \sum_{c = 1}^{N_{\mathrm{c}}} |y_{c1j}|^2,\]</p>where <span>$y_{c1j}$</span> is the image data for coil <span>$c$</span> of the first echo at voxel <span>$j$</span>. Then, for each echo, we coil combine in the following way:<p class="math-container">\[z_{nj} = \frac{1}{\sqrt{v_j}} \sum_{c = 1}^{N_{\mathrm{c}}} y_{c1j}^{*} y_{cnj}.\]</p></li></ol><p>The example that follows shows a simulated experiment where a B0 field map is estimated without knowledge of the coil sensitivies. This example examines B0 maps estimated when using both coil combination approaches and compares them to the case where coil sensitivity information is known. This example also compares the above regularized, iteratively estimated B0 maps to one obtained using a (non-iterative) phase contrast B0 mapping approach.</p><h2 id="Get-simulated-data"><a class="docs-heading-anchor" href="#Get-simulated-data">Get simulated data</a><a id="Get-simulated-data-1"></a><a class="docs-heading-anchor-permalink" href="#Get-simulated-data" title="Permalink"></a></h2><h3 id="Sensitivity-maps"><a class="docs-heading-anchor" href="#Sensitivity-maps">Sensitivity maps</a><a id="Sensitivity-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Sensitivity-maps" title="Permalink"></a></h3><p>Create a function for generating Gaussian-shaped, pure-real sensitivity maps.</p><pre><code class="language-julia hljs">function sensitivity_map(nx, ny, cx, cy, σ)

    s = [exp(-((x - cx)^2 + (y - cy)^2) / σ^2) for x in 1:nx, y in 1:ny]
    return complex.(s ./ maximum(s))

end;</code></pre><p>Specify the parameters for the sensitivity maps and then generate the maps.</p><pre><code class="language-julia hljs">nx = ny = 64
σ = 60
centers = [
    (nx ÷ 2, -100),
    (nx ÷ 2, 100 + ny + 1),
    (-100, ny ÷ 2),
    (100 + nx + 1, ny ÷ 2),
]
smap = cat([sensitivity_map(nx, ny, cx, cy, σ) for (cx, cy) in centers]...; dims = 3)
jim(smap; title = &quot;Sensitivity maps&quot;)</code></pre><img src="9ff40d71.svg" alt="Example block output"/><h3 id="Object"><a class="docs-heading-anchor" href="#Object">Object</a><a id="Object-1"></a><a class="docs-heading-anchor-permalink" href="#Object" title="Permalink"></a></h3><p>Create a disk-shaped object with uniform intensity (M0) throughout.</p><pre><code class="language-julia hljs">radius = 25
obj = [(x - nx÷2)^2 + (y - ny÷2)^2 &lt; radius^2 for x in 1:nx, y in 1:ny]
mask = obj .&gt; 0 # Mask indicating object support
jim(obj; title = &quot;Object&quot;)</code></pre><img src="db56ffc0.svg" alt="Example block output"/><h3 id="True-field-map"><a class="docs-heading-anchor" href="#True-field-map">True field map</a><a id="True-field-map-1"></a><a class="docs-heading-anchor-permalink" href="#True-field-map" title="Permalink"></a></h3><p>Create a linearly (spatially) varying field map.</p><pre><code class="language-julia hljs">ftrue = repeat(range(-50, 50, nx), 1, ny) * Hz
ftrue[nx÷2,ny÷2] = 50Hz # Add Kronecker impulse for visualizing regularization-induced blur
ftrue .*= mask # Mask out background voxels for better visualization
clim = (-60, 60) .* Hz # Use common colorbar limits for all field map plots
jim(ftrue; title = &quot;True field map&quot;, clim)</code></pre><img src="6f041abd.svg" alt="Example block output"/><h3 id="Data"><a class="docs-heading-anchor" href="#Data">Data</a><a id="Data-1"></a><a class="docs-heading-anchor-permalink" href="#Data" title="Permalink"></a></h3><p>Specify parameters for the simulated multi-echo, multi-coil data.</p><pre><code class="language-julia hljs">TE = (4.0ms, 6.3ms)
T2 = 40ms
σ_noise = 0.005; # Noise standard deviation</code></pre><p>Make a function for creating the simulated data for a given echo time.</p><pre><code class="language-julia hljs">function make_data(TE)

    data = @. smap * obj * exp(-TE / T2) * cispi(2TE * ftrue) # Noiseless
    @. data += complex(σ_noise * randn(), σ_noise * randn()) # Add complex Gaussian noise
    return data

end;</code></pre><p>Create the simulated data.</p><pre><code class="language-julia hljs">seed!(0)
ydata = cat(make_data.(TE)...; dims = 4)
jim(ydata; title = &quot;Simulated data&quot;, ncol = 4)</code></pre><img src="7b0b3791.svg" alt="Example block output"/><h2 id="Estimate-B0"><a class="docs-heading-anchor" href="#Estimate-B0">Estimate B0</a><a id="Estimate-B0-1"></a><a class="docs-heading-anchor-permalink" href="#Estimate-B0" title="Permalink"></a></h2><p>Now that we have the simulated data, we can estimate B0 from the data using the different approaches.</p><p>First, create a function for computing the RMSE of the estimated B0 maps and another function for displaying the B0 maps.</p><pre><code class="language-julia hljs">frmsd = (f1, f2) -&gt; 1Hz * round(sqrt(sum(abs2, (f1 - f2)[mask]) / count(mask))/1Hz; digits = 1)
frmse = f -&gt; frmsd(f, ftrue)
plotb0 = f -&gt; jim(f; title = &quot;RMSE = $(frmse(f))&quot;, clim);</code></pre><p>Also specify the strength of the regularization parameter, as well as the type of preconditioner to use. (Note that the default preconditioner used by <code>b0map</code> (<code>precon = :ichol</code>) does not produce good results in this example.)</p><pre><code class="language-julia hljs">l2b = -26 # Regularization parameter is β = 2^l2b
precon = :diag;</code></pre><h3 id="Use-coil-sensitivity-maps"><a class="docs-heading-anchor" href="#Use-coil-sensitivity-maps">Use coil sensitivity maps</a><a id="Use-coil-sensitivity-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Use-coil-sensitivity-maps" title="Permalink"></a></h3><pre><code class="language-julia hljs">fcoil = b0map(ydata, TE; smap, l2b, precon)[1] .* mask
plotb0(fcoil)</code></pre><img src="b011f93f.svg" alt="Example block output"/><h3 id="Assume-uniform-coil-sensitivities"><a class="docs-heading-anchor" href="#Assume-uniform-coil-sensitivities">Assume uniform coil sensitivities</a><a id="Assume-uniform-coil-sensitivities-1"></a><a class="docs-heading-anchor-permalink" href="#Assume-uniform-coil-sensitivities" title="Permalink"></a></h3><pre><code class="language-julia hljs">funiform = b0map(ydata, TE; smap = ones(eltype(smap), size(smap)), l2b, precon)[1] .* mask
plotb0(funiform)</code></pre><img src="8bd9dac7.svg" alt="Example block output"/><h3 id="Use-phase-contrast-based-approach"><a class="docs-heading-anchor" href="#Use-phase-contrast-based-approach">Use phase contrast-based approach</a><a id="Use-phase-contrast-based-approach-1"></a><a class="docs-heading-anchor-permalink" href="#Use-phase-contrast-based-approach" title="Permalink"></a></h3><pre><code class="language-julia hljs">fpc_iterative = b0map(ydata, TE; smap = nothing, l2b, precon)[1] .* mask
plotb0(fpc_iterative)</code></pre><img src="1fe04472.svg" alt="Example block output"/><h3 id="Do-conventional-(non-iterative)-phase-contrast-B0-mapping"><a class="docs-heading-anchor" href="#Do-conventional-(non-iterative)-phase-contrast-B0-mapping">Do conventional (non-iterative) phase contrast B0 mapping</a><a id="Do-conventional-(non-iterative)-phase-contrast-B0-mapping-1"></a><a class="docs-heading-anchor-permalink" href="#Do-conventional-(non-iterative)-phase-contrast-B0-mapping" title="Permalink"></a></h3><pre><code class="language-julia hljs">fpc = phasecontrast(ydata, TE) .* mask
plotb0(fpc)</code></pre><img src="89731d92.svg" alt="Example block output"/><h3 id="Show-all-field-maps-together"><a class="docs-heading-anchor" href="#Show-all-field-maps-together">Show all field maps together</a><a id="Show-all-field-maps-together-1"></a><a class="docs-heading-anchor-permalink" href="#Show-all-field-maps-together" title="Permalink"></a></h3><pre><code class="language-julia hljs">annotate = (col, row, title; fontsize = 12) -&gt; begin
    x = nx ÷ 2 + nx * (col - 1)
    y = 4 + ny * (row - 1)
    return (x, y, (title, fontsize))
end
annotation = [
    annotate(1, 1, &quot;ftrue&quot;),
    annotate(2, 1, &quot;fcoil&quot;),
    annotate(3, 1, &quot;funiform&quot;),
    annotate(2, 2, &quot;fpc_iterative&quot;),
    annotate(3, 2, &quot;fpc&quot;),
]
fzero = zeros(eltype(ftrue), size(ftrue))
fmaps = [ftrue;;; fcoil;;; funiform;;; fzero;;; fpc_iterative;;; fpc]
jim(fmaps; clim, annotation, ncol = 3)</code></pre><img src="1ba9e487.svg" alt="Example block output"/><p>Display the RMSE of each field map.</p><pre><code class="language-julia hljs">[
    &quot;Method&quot;       &quot;RMSE&quot;;
    :fcoil         frmse(fcoil);
    :funiform      frmse(funiform);
    :fpc_iterative frmse(fpc_iterative);
    :fpc           frmse(fpc);
]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5×2 Matrix{Any}:
 &quot;Method&quot;              &quot;RMSE&quot;
 :fcoil          1.4 Hz
 :funiform       1.7 Hz
 :fpc_iterative  1.4 Hz
 :fpc            1.4 Hz</code></pre><p>Compute the root mean square difference between the iterative B0 mapping approach that used the phase contrast-based coil combination method and the conventional phase contrast B0 map.</p><pre><code class="language-julia hljs">println(&quot;RMSD = &quot;, frmsd(fpc_iterative, fpc))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">RMSD = 0.0 Hz</code></pre><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>In this example, the iterative B0-mapping method that used the phase contrast-based coil combination method performed just as well (in terms of RMSE) as the approach that used coil-sensitivity information for coil combination. The iterative approach that did coil combination assuming uniform coil sensitivities did slightly worse, and the non-iterative phase contrast approach had the worst RMSE. However, in this example, all the approaches performed fairly well; perhaps a different data set would result in more dramatic differences.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../02-b0map/">« B0 field map</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Friday 17 May 2024 22:06">Friday 17 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
