var documenterSearchIndex = {"docs":
[{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"EditURL = \"../../../lit/examples/03-phasecontrast.jl\"","category":"page"},{"location":"generated/examples/03-phasecontrast/#03-phasecontrast","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"","category":"section"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"This page illustrates regularized B0 3D field map estimation from multi-echo, multi-coil MRI images using the Julia package MRIFieldmaps. In this case, we assume we do not have access to coil sensitivity maps. Instead of using those maps for coil combination, we will use a phase contrast-based approach.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"This page comes from a single Julia file: 03-phasecontrast.jl.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"You can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 03-phasecontrast.ipynb, or open it in binder here: 03-phasecontrast.ipynb.","category":"page"},{"location":"generated/examples/03-phasecontrast/#Setup","page":"Phase contrast B0 mapping","title":"Setup","text":"","category":"section"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"Packages needed here.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"using MRIFieldmaps: b0map, phasecontrast\nusing MIRTjim: jim, prompt; jim(:prompt, true)\nusing Random: seed!\nusing Unitful: s, ms, Hz","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"The following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"generated/examples/03-phasecontrast/#Overview","page":"Phase contrast B0 mapping","title":"Overview","text":"","category":"section"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"When estimating B0 field maps from multi-coil data, the images first can be coil-combined in a way that preserves image phase. Ideally, one has access to coil sensitivity maps that can be used for the coil combination. However, coil sensitivity maps are not always available (e.g., for B0 shimming). One way of coil combining the images without coil sensitivity maps is to pretend all the coils are uniformly sensitive across the object (i.e., assume the sensitivity maps are uniformly equal to 1). Alternatively, one can effectively use the multi-coil images themselves to glean information about the coil sensitivies and coil combine the images using a phase contrast-based approach.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"We now review the B0 mapping procedure so that we can then understand how the choice of coil combination scheme influences the estimated field map. For the case we are considering, where coil combination is done as a preprocessing step, the regularized, iterative B0 mapping procedure seeks to minimize","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"Psi(mathbfomega) = Phi(mathbfomega) + fracbeta2 mathbfC mathbfomega_2^2","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"where mathbfomega is the field map, Phi(mathbfomega) computes the data fit term, mathbfC is a finite difference operator to encourage spatial smoothness of the field map, and beta is a regularization parameter. The data fit term is given by","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"Phi(mathbfomega) = sum_j = 1^N_mathrmv sum_m n = 1^N_mathrme phi_mnj(omega_j)","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"where N_mathrmv is the number of image voxels, N_mathrme is the number of echoes, and","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"phi_mnj(omega_j) = r_mnj 1 - cos(angle r_mnj + omega_j (t_m - t_n))","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"Here, t_m - t_n represents the echo time difference between the mth and nth echoes, and","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"r_mnj = frac1N_mathrme z_mj^* z_nj","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"where z_nj is the (coil-combined) image value for echo n at voxel j, and (cdot)^* denotes complex conjugate.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"We now consider what z_nj looks like for the coil combination schemes discussed.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"Coil combination using coil sensitivities: In this case, we first compute the sum-of-squares of the sensitivity maps:\nv_j = sum_c = 1^N_mathrmc s_cj^2\nwhere s_cj is the coil sensitivity of coil c at voxel j, and N_mathrmc is the number of coils. We then use the sensitivity maps for the coil combination:\nz_nj = frac1sqrtv_j sum_c = 1^N_mathrmc s_cj^* y_cnj\nwhere y_cnj is the image data for coil c of echo n at voxel j.\nTaking coil sensitivities to be uniformly equal to 1: In this case, s_cj = 1  forall c j, so v_j = N_mathrmc and\nz_nj = frac1sqrtN_mathrmc sum_c = 1^N_mathrmc y_cnj\nPhase contrast-based approach: In this case, we first coil combine the first echo image by taking the sum-of-squares across coils:\nv_j = sum_c = 1^N_mathrmc y_c1j^2\nwhere y_c1j is the image data for coil c of the first echo at voxel j. Then, for each echo, we coil combine in the following way:\nz_nj = frac1sqrtv_j sum_c = 1^N_mathrmc y_c1j^* y_cnj","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"The example that follows shows a simulated experiment where a B0 field map is estimated without knowledge of the coil sensitivies. This example examines B0 maps estimated when using both coil combination approaches and compares them to the case where coil sensitivity information is known. This example also compares the above regularized, iteratively estimated B0 maps to one obtained using a (non-iterative) phase contrast B0 mapping approach.","category":"page"},{"location":"generated/examples/03-phasecontrast/#Get-simulated-data","page":"Phase contrast B0 mapping","title":"Get simulated data","text":"","category":"section"},{"location":"generated/examples/03-phasecontrast/#Sensitivity-maps","page":"Phase contrast B0 mapping","title":"Sensitivity maps","text":"","category":"section"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"Create a function for generating Gaussian-shaped, pure-real sensitivity maps.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"function sensitivity_map(nx, ny, cx, cy, σ)\n\n    s = [exp(-((x - cx)^2 + (y - cy)^2) / σ^2) for x in 1:nx, y in 1:ny]\n    return complex.(s ./ maximum(s))\n\nend;\nnothing #hide","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"Specify the parameters for the sensitivity maps and then generate the maps.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"nx = ny = 64\nσ = 60\ncenters = [\n    (nx ÷ 2, -100),\n    (nx ÷ 2, 100 + ny + 1),\n    (-100, ny ÷ 2),\n    (100 + nx + 1, ny ÷ 2),\n]\nsmap = cat([sensitivity_map(nx, ny, cx, cy, σ) for (cx, cy) in centers]...; dims = 3)\njim(smap; title = \"Sensitivity maps\")","category":"page"},{"location":"generated/examples/03-phasecontrast/#Object","page":"Phase contrast B0 mapping","title":"Object","text":"","category":"section"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"Create a disk-shaped object with uniform intensity (M0) throughout.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"radius = 25\nobj = [(x - nx÷2)^2 + (y - ny÷2)^2 < radius^2 for x in 1:nx, y in 1:ny]\nmask = obj .> 0 # Mask indicating object support\njim(obj; title = \"Object\")","category":"page"},{"location":"generated/examples/03-phasecontrast/#True-field-map","page":"Phase contrast B0 mapping","title":"True field map","text":"","category":"section"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"Create a linearly (spatially) varying field map.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"ftrue = repeat(range(-50, 50, nx), 1, ny) * Hz\nftrue[nx÷2,ny÷2] = 50Hz # Add Kronecker impulse for visualizing regularization-induced blur\nftrue .*= mask # Mask out background voxels for better visualization\nclim = (-60, 60) .* Hz # Use common colorbar limits for all field map plots\njim(ftrue; title = \"True field map\", clim)","category":"page"},{"location":"generated/examples/03-phasecontrast/#Data","page":"Phase contrast B0 mapping","title":"Data","text":"","category":"section"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"Specify parameters for the simulated multi-echo, multi-coil data.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"TE = (4.0ms, 6.3ms)\nT2 = 40ms\nσ_noise = 0.005; # Noise standard deviation\nnothing #hide","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"Make a function for creating the simulated data for a given echo time.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"function make_data(TE)\n\n    data = @. smap * obj * exp(-TE / T2) * cispi(2TE * ftrue) # Noiseless\n    @. data += complex(σ_noise * randn(), σ_noise * randn()) # Add complex Gaussian noise\n    return data\n\nend;\nnothing #hide","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"Create the simulated data.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"seed!(0)\nydata = cat(make_data.(TE)...; dims = 4)\njim(ydata; title = \"Simulated data\", ncol = 4)","category":"page"},{"location":"generated/examples/03-phasecontrast/#Estimate-B0","page":"Phase contrast B0 mapping","title":"Estimate B0","text":"","category":"section"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"Now that we have the simulated data, we can estimate B0 from the data using the different approaches.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"First, create a function for computing the RMSE of the estimated B0 maps and another function for displaying the B0 maps.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"frmsd = (f1, f2) -> 1Hz * round(sqrt(sum(abs2, (f1 - f2)[mask]) / count(mask))/1Hz; digits = 1)\nfrmse = f -> frmsd(f, ftrue)\nplotb0 = f -> jim(f; title = \"RMSE = $(frmse(f))\", clim);\nnothing #hide","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"Also specify the strength of the regularization parameter, as well as the type of preconditioner to use. (Note that the default preconditioner used by b0map (precon = :ichol) does not produce good results in this example.)","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"l2b = -26 # Regularization parameter is β = 2^l2b\nprecon = :diag;\nnothing #hide","category":"page"},{"location":"generated/examples/03-phasecontrast/#Use-coil-sensitivity-maps","page":"Phase contrast B0 mapping","title":"Use coil sensitivity maps","text":"","category":"section"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"fcoil = b0map(ydata, TE; smap, l2b, precon)[1] .* mask\nplotb0(fcoil)","category":"page"},{"location":"generated/examples/03-phasecontrast/#Assume-uniform-coil-sensitivities","page":"Phase contrast B0 mapping","title":"Assume uniform coil sensitivities","text":"","category":"section"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"funiform = b0map(ydata, TE; smap = ones(eltype(smap), size(smap)), l2b, precon)[1] .* mask\nplotb0(funiform)","category":"page"},{"location":"generated/examples/03-phasecontrast/#Use-phase-contrast-based-approach","page":"Phase contrast B0 mapping","title":"Use phase contrast-based approach","text":"","category":"section"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"fpc_iterative = b0map(ydata, TE; smap = nothing, l2b, precon)[1] .* mask\nplotb0(fpc_iterative)","category":"page"},{"location":"generated/examples/03-phasecontrast/#Do-conventional-(non-iterative)-phase-contrast-B0-mapping","page":"Phase contrast B0 mapping","title":"Do conventional (non-iterative) phase contrast B0 mapping","text":"","category":"section"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"fpc = phasecontrast(ydata, TE) .* mask\nplotb0(fpc)","category":"page"},{"location":"generated/examples/03-phasecontrast/#Show-all-field-maps-together","page":"Phase contrast B0 mapping","title":"Show all field maps together","text":"","category":"section"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"annotate = (col, row, title; fontsize = 12) -> begin\n    x = nx ÷ 2 + nx * (col - 1)\n    y = 4 + ny * (row - 1)\n    return (x, y, (title, fontsize))\nend\nannotation = [\n    annotate(1, 1, \"ftrue\"),\n    annotate(2, 1, \"fcoil\"),\n    annotate(3, 1, \"funiform\"),\n    annotate(2, 2, \"fpc_iterative\"),\n    annotate(3, 2, \"fpc\"),\n]\nfzero = zeros(eltype(ftrue), size(ftrue))\nfmaps = [ftrue;;; fcoil;;; funiform;;; fzero;;; fpc_iterative;;; fpc]\njim(fmaps; clim, annotation, ncol = 3)","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"Display the RMSE of each field map.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"[\n    \"Method\"       \"RMSE\";\n    :fcoil         frmse(fcoil);\n    :funiform      frmse(funiform);\n    :fpc_iterative frmse(fpc_iterative);\n    :fpc           frmse(fpc);\n]","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"Compute the root mean square difference between the iterative B0 mapping approach that used the phase contrast-based coil combination method and the conventional phase contrast B0 map.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"println(\"RMSD = \", frmsd(fpc_iterative, fpc))","category":"page"},{"location":"generated/examples/03-phasecontrast/#Summary","page":"Phase contrast B0 mapping","title":"Summary","text":"","category":"section"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"In this example, the iterative B0-mapping method that used the phase contrast-based coil combination method performed just as well (in terms of RMSE) as the approach that used coil-sensitivity information for coil combination. The iterative approach that did coil combination assuming uniform coil sensitivities did slightly worse, and the non-iterative phase contrast approach had the worst RMSE. However, in this example, all the approaches performed fairly well; perhaps a different data set would result in more dramatic differences.","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"","category":"page"},{"location":"generated/examples/03-phasecontrast/","page":"Phase contrast B0 mapping","title":"Phase contrast B0 mapping","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"EditURL = \"../../../lit/examples/02-b0map.jl\"","category":"page"},{"location":"generated/examples/02-b0map/#02-b0map","page":"B0 field map","title":"B0 field map","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"This page illustrates regularized B0 3D field map estimation from multi-echo multi-coil MRI images using the Julia package MRIFieldmaps.","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"This page comes from a single Julia file: 02-b0map.jl.","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"You can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 02-b0map.ipynb, or open it in binder here: 02-b0map.ipynb.","category":"page"},{"location":"generated/examples/02-b0map/#Setup","page":"B0 field map","title":"Setup","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Packages needed here.","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"using MRIFieldmaps: b0map, b0model, b0init, b0scale\nusing MIRTjim: jim, prompt; jim(:prompt, true)\nusing MAT: matread\nimport Downloads # todo: use Fetch or DataDeps?\nusing MIRT: ir_mri_sensemap_sim\nusing Random: seed!\nusing StatsBase: mean\nusing Unitful: s\nusing Plots; default(markerstrokecolor=:auto, label=\"\")","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"The following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"generated/examples/02-b0map/#Overview","page":"B0 field map","title":"Overview","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"This example is based on the simulation example from the repo that reproduces Experiment A and Figs. 3 & 4 in the paper \"Efficient Regularized Field Map Estimation in 3D MRI\" by Claire Lin and Jeff Fessler, 2020","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"This example uses units (seconds) to illustrate that capability of the package, but units are not required.","category":"page"},{"location":"generated/examples/02-b0map/#Read-data","page":"B0 field map","title":"Read data","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"if !@isdefined(data)\n    repo = \"https://github.com/ClaireYLin/regularized-field-map-estimation\"\n    dataurl = \"$repo/blob/main/data/input_object_40sl_3d_epi_snr40.mat?raw=true\"\n    data = matread(Downloads.download(dataurl))\nend;\nnothing #hide","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Extract arrays used in simulation","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"if !@isdefined(ftrue)\n    zp = 1:40 # choose subset of slices\n    mask = data[\"maskR\"][:,:,zp]\n    ftrue = (data[\"in_obj\"][\"ztrue\"][:,:,zp] .* mask) / 2π / 1s # Hz\n    ftrue .*= mask # true field map (in Hz) for simulation\n    mag = data[\"in_obj\"][\"xtrue\"] .* mask # true baseline magnitude\n    if false # 2× in all 3 dimensions to make (128,128,80) for timing test (≈6sec)\n        catd = (x,d) -> cat(x, x, dims=d)\n        bigify = (x) -> catd(catd(catd(x, 1), 2), 3)\n        ftrue = bigify(ftrue)\n        mag = bigify(mag)\n        mask = bigify(mask)\n    end\n    (nx,ny,nz) = size(mag)\n    clim = (-100,100) # display range in Hz\n    jim(ftrue .* mask; clim, title=\"True fieldmap in Hz (Fig 3d)\")\nend","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Function for computing RMSE within the mask","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"frmse = f -> round(sqrt(sum(abs2, (f - ftrue)[mask]) / count(mask)) * s, digits=1) / s;\nnothing #hide","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Parameters for data generation","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"echotime = [0, 2, 10] * 1f-3 * 1s # echo times in sec\ntrue_thresh = 0.05 # threshold of the true object for determining reconstruction mask\nsnr = 24 # noise level in dB\nne = length(echotime)\nnc = 4; # number of coils in simulation\nnothing #hide","category":"page"},{"location":"generated/examples/02-b0map/#Simulate-sensitivity-maps","page":"B0 field map","title":"Simulate sensitivity maps","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"(rcoil=100 to match matlab default). todo: polynomial approximation?","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"if !@isdefined(smap)\n    smap = ir_mri_sensemap_sim(; dims=(nx, ny, nz), ncoil=nc, rcoil=100)\n    div0 = (x::Number,y::Number) -> iszero(y) ? 0 : x/y\n    smap ./= sqrt.(sum(abs2, smap; dims=4)) # normalize by SSoS\n    jim(smap, \"|smap|\"; ncol=nz÷2)\nend","category":"page"},{"location":"generated/examples/02-b0map/#Generate-simulated-image-data","page":"B0 field map","title":"Generate simulated image data","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"This is the multi-coil version, for multiple echo times, with additive complex Gaussian noise.","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Because b0model uses cis(+phase), the resulting fieldmap may be the negative of the needed for your scanner!","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"ytrue = b0model(ftrue, mag, echotime; smap)\nseed!(0) # matlab and julia will differ","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"compute the noise_std to get the desired SNR","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"image_power = 10 * log10(sum(abs2, mag) / (nx*ny*nz)) # in dB\nnoise_power = image_power - snr\nnoise_std = sqrt(10^(noise_power/10)) / 2 # because complex\nynoise = Float32(noise_std) * randn(ComplexF32, size(ytrue))\nydata = ytrue + ynoise; # add the noise to the data\nnothing #hide","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Compute the SNR for each echo time to verify","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"tmp = [sum(abs2, ytrue[:,:,:,:,i]) / sum(abs2, ynoise[:,:,:,:,i]) for i in 1:ne]\ndatasnr = 10 * log10.(tmp)","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Show data magnitude","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"jim(ydata[:,:,:,:,end], \"|data|\"; ncol=nz÷2)","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Coil combine image data and scale","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"if !@isdefined(yik_sos)\n    yik_sos = sum(conj(smap) .* ydata; dims=4) # coil combine\n    yik_sos = yik_sos[:,:,:,1,:] # (dims..., ne)\n    jim(yik_sos, \"|data sos|\"; ncol=nz÷2)\n    (yik_sos_scaled, scale) = b0scale(yik_sos, echotime) # todo\n    jim(yik_sos_scaled, \"|scaled data|\"; ncol=nz÷2)\nend","category":"page"},{"location":"generated/examples/02-b0map/#Initialize-fieldmap","page":"B0 field map","title":"Initialize fieldmap","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Compute finit using phase difference of first two echo times (no smoothing):","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"finit = b0init(ydata, echotime; smap)\njim(finit .* mask; clim, title=\"Initial fieldmap in Hz (Fig 3b)\",\n    xlabel = \"RMSE = $(frmse(finit)) Hz\")","category":"page"},{"location":"generated/examples/02-b0map/#Run-NCG","page":"B0 field map","title":"Run NCG","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Run each algorithm twice; once to track rmse and costs, once for timing","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"yik_scale = ydata / scale\nfmap_run = (niter, precon, track; kwargs...) ->\n    b0map(yik_scale, echotime; smap, mask,\n       order=1, l2b=-4, gamma_type=:PR, niter, precon, track, kwargs...)\n\nfunction runner(niter, precon; kwargs...)\n    (fmap, _, out) = fmap_run(niter, precon, true; kwargs...) # tracking run\n    (_, times, _) = fmap_run(niter, precon, false; kwargs...) # timing run\n    return (fmap, out.fhats, out.costs, times)\nend;\nnothing #hide","category":"page"},{"location":"generated/examples/02-b0map/#2.-NCG:-no-precon","page":"B0 field map","title":"2. NCG: no precon","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"if !@isdefined(fmap_cg_n)\n    niter_cg_n = 50\n    (fmap_cg_n, fhat_cg_n, cost_cg_n, time_cg_n) = runner(niter_cg_n, :I)\n\n    pcost = plot(time_cg_n, cost_cg_n, marker=:circle, label=\"NCG-MLS\");\n    pi_cn = jim(fmap_cg_n, \"CG:I\"; clim,\n        xlabel = \"RMSE = $(frmse(fmap_cg_n)) Hz\")\nend","category":"page"},{"location":"generated/examples/02-b0map/#3.-NCG:-diagonal-preconditioner","page":"B0 field map","title":"3. NCG: diagonal preconditioner","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"if !@isdefined(fmap_cg_d)\n    niter_cg_d = 40\n    (fmap_cg_d, fhat_cg_d, cost_cg_d, time_cg_d) = runner(niter_cg_d, :diag)\n\n    plot!(pcost, time_cg_d, cost_cg_d, marker=:square, label=\"NCG-MLS-D\")\n    pi_cd = jim(fmap_cg_d, \"CG:diag\"; clim,\n        xlabel = \"RMSE = $(frmse(fmap_cg_d)) Hz\")\nend","category":"page"},{"location":"generated/examples/02-b0map/#4.-NCG:-Cholesky-preconditioner","page":"B0 field map","title":"4. NCG: Cholesky preconditioner","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"(This one may use too much memory for larger images.)","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"if !@isdefined(fmap_cg_c)\n    niter_cg_c = 3\n    (fmap_cg_c, fhat_cg_c, cost_cg_c, time_cg_c) = runner(niter_cg_c, :chol)\n\n    plot!(pcost, time_cg_c, cost_cg_c, marker=:square, label=\"NCG-MLS-C\")\n    pi_cc = jim(fmap_cg_c, \"CG:chol\"; clim,\n        xlabel = \"RMSE = $(frmse(fmap_cg_c)) Hz\")\nend","category":"page"},{"location":"generated/examples/02-b0map/#5.-NCG:-Incomplete-Cholesky-preconditioner","page":"B0 field map","title":"5. NCG: Incomplete Cholesky preconditioner","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"if !@isdefined(fmap_cg_i)\n    niter_cg_i = 14\n    (fmap_cg_i, fhat_cg_i, cost_cg_i, time_cg_i) =\n        runner(niter_cg_i, :ichol; lldl_args = (; memory=20, droptol=0))\n\n    plot!(pcost, time_cg_i, cost_cg_i, marker=:square, label=\"NCG-MLS-IC\",\n        xlabel = \"time [s]\", ylabel=\"cost\")\n    pi_ci = jim(fmap_cg_i, \"CG:ichol\"; clim,\n        xlabel = \"RMSE = $(frmse(fmap_cg_i)) Hz\")\nend","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Compare final RMSE values","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"frmse.((ftrue, finit, fmap_cg_n, fmap_cg_d, fmap_cg_c, fmap_cg_i))","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Plot RMSE vs wall time","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"prmse = plot(xlabel = \"time [s]\", ylabel=\"RMSE [Hz]\")\nfun = (time, fhat, label) ->\n    plot!(prmse, time, frmse.(eachslice(fhat; dims=4)); label, marker=:circ)\nfun(time_cg_n, fhat_cg_n, \"None\")\nfun(time_cg_d, fhat_cg_d, \"Diag\")\nfun(time_cg_c, fhat_cg_c, \"Chol\")\nfun(time_cg_i, fhat_cg_i, \"IC\")","category":"page"},{"location":"generated/examples/02-b0map/#Discussion","page":"B0 field map","title":"Discussion","text":"","category":"section"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"That final figure is similar to Fig. 4 of the 2020 Lin&Fessler paper, after correcting that figure for a factor of π.","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"This figure was generated in github's cloud, where the servers are busily multi-tasking, so the compute times per iteration can vary widely between iterations and runs.","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"Nevertheless, it is interesting that in this Julia implementation the diagonal preconditioner seems to be as effective as the incomplete Cholesky preconditioner.","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"","category":"page"},{"location":"generated/examples/02-b0map/","page":"B0 field map","title":"B0 field map","text":"This page was generated using Literate.jl.","category":"page"},{"location":"methods/#Methods-list","page":"Methods","title":"Methods list","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"","category":"page"},{"location":"methods/#Methods-usage","page":"Methods","title":"Methods usage","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Modules = [MRIFieldmaps]","category":"page"},{"location":"methods/#MRIFieldmaps.MRIFieldmaps","page":"Methods","title":"MRIFieldmaps.MRIFieldmaps","text":"MRIFieldmaps\n\nModule MRIFieldmaps exports methods for fieldmap estimation.\n\n\n\n\n\n","category":"module"},{"location":"methods/#MRIFieldmaps.Echotime","page":"Methods","title":"MRIFieldmaps.Echotime","text":"Echotime{T} = Union{AbstractVector{<:T}, NTuple{N,<:T} where N}\n\nThe echo times can be a vector or a Tuple.\n\n\n\n\n\n","category":"type"},{"location":"methods/#MRIFieldmaps.RealU","page":"Methods","title":"MRIFieldmaps.RealU","text":"RealU\n\nA data type that is just Number but is to be thought of as Union{Real, Unitful} without needing a dependence on the Unitful package.\n\n\n\n\n\n","category":"type"},{"location":"methods/#MRIFieldmaps.b0init-Union{Tuple{Te}, Tuple{D}, Tuple{AbstractArray{<:Complex, D}, Union{AbstractVector{<:Te}, Tuple{Vararg{var\"#s2\", N}} where {N, var\"#s2\"<:Te}}}} where {D, Te<:Number}","page":"Methods","title":"MRIFieldmaps.b0init","text":"finit = b0init(ydata, echotime; kwargs...)\n\nClassic B0 field map estimation based on the phase difference of complex images at two different echo times. If sensitivity maps (smap) are provided, complex coil combination is done first. This code works with images of arbitrary dimensions (2D, 3D, etc.), and with multiple coils.\n\nIn the usual case where echotime has units of seconds, the returned B0 fieldmap will have units of Hz.\n\nIf df is nonempty (which always holds for water-fat case), then perform discrete maximum-likelihood estimation using fdict.\n\nIn\n\nydata (dims..., nc, ne) ne sets of complex images for nc ≥ 1 coils\nechotime (ne) vector of ne ≥ 2 echo times (only first 2 are used)\n\nOptions\n\nsmap (dims..., nc) complex coil maps; default nothing\nthreshold set finit values where |y1| < threshold * max(|y1|)  to the mean of the \"good\" values where |y1| ≥ threshold * max(|y1|).  default: 0.1\n\nOptions for water-fat case:\n\ndf Δf values in water-fat imaging (def: []) units Hz, e.g., [440] at 3T\nrelamp relative amplitudes in multi-species water-fat (def: [])\nfband frequency bandwidth for fdict; defaultfloor(1 / minimum(echo time spacing))`\nnf number of discrete frequencies to try; default 1+floor(fband) so ≈1Hz spacing\nfdict \"dictionary\" of discrete frequency values to try; default LinRange(-1/2,1/2,nf) * fband\n\nOut\n\nfinit initial B0 fieldmap estimate in Hz\n\n\n\n\n\n","category":"method"},{"location":"methods/#MRIFieldmaps.b0map","page":"Methods","title":"MRIFieldmaps.b0map","text":"(fhat, times, out) = b0map(ydata, echotime; kwargs...)\n\nField map estimation from multiple (ne ≥ 2) echo-time images, using preconditioned nonlinear CG (NCG) with a monotonic line search. This code works with images of arbitrary dimensions (2D, 3D, etc.), and with multiple coils.\n\nCaution: single coil data must be reshaped to size (dims..., 1, ne).\n\nThe cost function for the single-coil case is: cost(w) = ∑_{j=1}^{#voxel} ∑_{m=1}^ne ∑_{n=1}^ne     |y_{mj} y_{nj}| wj (1 - cos(w_j * (t_m - t_n) + ∠y_{ni} - ∠y_{mj})) + R(w) where t_n denotes the echo time of the nth scan and R(w) = 0.5 * | C * w |^2 is a quadratic roughness regularizer based on 1st-order or 2nd-order finite differences. See the documentation for the general multi-coil case.\n\nThe initial field map finit and output fhat are field maps in Hz, but internally the code works with ω = 2π f (rad/s).\n\nIn\n\nydata (dims..., nc, ne) ne sets of complex images for nc ≥ 1 coils\nechotime::Echotime (ne ≥ 2) echo time offsets (in seconds)\n\nOptions\n\nfinit (dims) initial fieldmap estimate (in Hz); default from b0init()\nsmap (dims..., nc) complex coil maps; default nothing\nmask (dims...) logical reconstruction mask; default: trues(size(finit))\nninner # of inner iterations for monotonic line search default: 3 inner iterations\nb0init_args::NamedTuple = (;) options for b0init, such as threshold\nniter # of outer iterations (def: 30)\norder order of the finite-difference matrix (def: 2)\nl2b log2 of regularization parameter (def: -6)\ngamma_type CG direction:\n:PR = Polak-Ribiere (default)\n:FR = Fletcher-Reeves\nprecon Preconditioner:\n:I (nothing)\n:diag\n:chol may require too much memory\n:ichol (default)\nreset # of iterations before resetting direction (def: Inf)\ndf Δf values in water-fat imaging (def: [0]) units Hz, e.g., [440] at 3T\nrelamp relative amplitudes in multi-peak water-fat (def: [1])\nlldl_args::NamedTuple options for lldl, default: (;memory=2)\ntrack::Bool if true then track cost and save all iterations (def: false)\nchat::Bool = true # @info updates each iteration\nchat_iter::Int = 10 # print progress report every few iterations.\n\nOut\n\nfhat final fieldmap estimate in Hz\ntimes (niter+1) wall time for each iteration\nout::NamedTuple that contains:\n(xw, xf) (dims) water / fat images if !iszero(df)\nfinit (dims) initial fieldmap\nif track == true then out also contains:\ncosts (niter+1) (nonconvex) cost for each iteration\nfhats (dims, niter+1) fieldmap estimates every iteration\n\nThe algorithm is based on the paper: C Y Lin, J A Fessler, \"Efficient Regularized Field Map Estimation in 3D MRI\", IEEE TCI 2020 https://doi.org/10.1109/TCI.2020.3031082 https://arxiv.org/abs/2005.08661\n\nPlease cite that paper if you use this code.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MRIFieldmaps.b0map-Tuple{AbstractVector{<:Number}, AbstractMatrix{<:Complex}, AbstractVector{<:Real}, Union{AbstractVector{<:T}, Tuple{Vararg{var\"#s2\", N}} where {N, var\"#s2\"<:T}} where T, AbstractArray{<:Bool}}","page":"Methods","title":"MRIFieldmaps.b0map","text":"b0map()\n\nThis version expects masked column-like inputs. For expert use only.\n\nIn\n\nfinit (np) initial estimate in Hz (np is # of pixels in mask)\nzdata (np, ne) ne sets of coil-combined measurements\nsos (np) sum-of-squares of coil maps\nechotime (ne) vector of ne echo time offsets\nmask (N) logical reconstruction mask\n\n\n\n\n\n","category":"method"},{"location":"methods/#MRIFieldmaps.b0model-Union{Tuple{Tx}, Tuple{Tf}, Tuple{Te}, Tuple{D}, Tuple{AbstractArray{Tf, D}, AbstractArray{Tx, D}, Union{AbstractVector{<:Te}, Tuple{Vararg{var\"#s2\", N}} where {N, var\"#s2\"<:Te}}}} where {D, Te<:Number, Tf<:Number, Tx<:Number}","page":"Methods","title":"MRIFieldmaps.b0model","text":"b0model(fmap, xw, echotime; kwargs...)\n\nCompute complex images for B0 field mapping. This function is used mainly for simulation, and for code testing.\n\nModel: images[j,c,l] = smap[j,c] exp(ı 2π fmap[j] t_l) exp(-relax[j] t_l) x[j,l] where x[j,l] = xw[j] + xf[j] * sum_{p=0}^P α_p exp(ı 2π Δf_p t_l).\n\nField map estimation from multiple (ne ≥ 2) echo-time images,\n\nIn\n\nfmap (dims) fieldmap (in Hz)\nxw (dims) water magnetization component\nechotime (ne) vector or Tuple of ne echo time offsets (in sec)\n\nOptions\n\nsmap (dims..., nc) complex coil maps, default ones(size(fmap)..., 1)\nxw (dims) fat magnetization component, default zeros(size(fmap))\ndf Δf values in water-fat imaging (def: [0]) units Hz, e.g., [440] at 3T\nrelamp relative amplitudes in multi-peak water-fat (def: [1])\nrelax (dims) R2* relaxation in same units as fmap, i.e., 1/s\n\nOut\n\nydata (dims..., nc, ne) ne sets of complex images for nc coils\n\n\n\n\n\n","category":"method"},{"location":"methods/#MRIFieldmaps.b0scale-Union{Tuple{Te}, Tuple{AbstractArray{<:Complex}, Union{AbstractVector{<:Te}, Tuple{Vararg{var\"#s2\", N}} where {N, var\"#s2\"<:Te}}}} where Te<:Number","page":"Methods","title":"MRIFieldmaps.b0scale","text":"(ydata, scalefactor) = b0scale(ydata, echotime; dmax)\n\nScale complex images ydata to account for R2* effects and for magnitude variations using median(di) where\n\nri = sum_j sum_k |y_{ij} y_{ik}|^2 (t_k - t_j)^2\ndi = ri / sum_k |y_{ik}|^2\n\nOnly values where di > dmax * maximum(di) affect scalefactor, so it is fine to pass unmasked images here.\n\nThis normalization simplifies regularization parameter selection for regularized B0 fieldmap estimation. See eqn (9) and (15) of Funai & Fessler, Oct. 2008, IEEE T-MI, https://doi.org/10.1109/TMI.2008.923956\n\nIn\n\nydata (dims..., ne) scan images for ne different echo times\nechotime (ne) echo times (units of sec if fieldmap is in Hz)\n\nOption\n\ndmax::Real threshold for relative di value (default 0.1)\n\nOut\n\nydata (dims..., ne) scaled scan images\nscalefactor = sqrt(median(rj))\n\n\n\n\n\n","category":"method"},{"location":"methods/#MRIFieldmaps.coil_combine-Tuple{AbstractArray{<:Complex}, AbstractArray{<:Complex}}","page":"Methods","title":"MRIFieldmaps.coil_combine","text":"zdata, sos = coil_combine(ydata [, smap])\n\nFor estimating a B0 field map from complete multi-coil image data, it suffices to first do complex coil combination, while tracking the sum-of-squares sos for proper weighting. When sensitivity maps are provided, often sos is all 1's and 0's.\n\nUses a phase contrast coil combination approach (reference below) when sensitivity maps are not provided.\n\nIn\n\nydata (dims..., nc, ne) ne ≥ 1 sets of complex images for nc ≥ 1 coils\nsmap (dims..., nc) complex coil maps (optional)\n\nOut\n\nzdata (dims..., ne) complex coil combination: sum_c smap[c]' * ydata[c] ./ sos or sum_c ydata[c,1]' * ydata[c] ./ sos (if smap not provided or isnothing(smap))\nsos (dims...) sum-of-squares: sum_c |smap[c]|^2 or sqrt.(sum_c |ydata[c,1]|^2 (if smap not provided or isnothing(smap))\n\nSee equation [13] in M A Bernstein et al., \"Reconstructions of Phase Contrast, Phased Array Multicoil Data\", MRM 1994. https://doi.org/10.1002/mrm.1910320308\n\n\n\n\n\n","category":"method"},{"location":"methods/#MRIFieldmaps.phasecontrast-Union{Tuple{Array{<:Complex, D}}, Tuple{D}} where D","page":"Methods","title":"MRIFieldmaps.phasecontrast","text":"pc = phasecontrast(ydata)\nfhat = phasecontrast(ydata, echotime)\n\nCompute the phase contrast between two multicoil data sets. If echotime is provided, return a field map by converting from radians to Hz (if echotime is in seconds, as is typical).\n\nIn\n\nydata (dims..., nc, ne) ne sets of complex images for nc ≥ 1 coils\nechotime::Echotime (ne = 2) echo time offsets\n\nOut\n\npc (dims...) phase contrast (or field map, if echotime is provided): ∠(sum_c ydata[c,1]' * ydata[c,2])\n\nSee equation [13] in M A Bernstein et al., \"Reconstructions of Phase Contrast, Phased Array Multicoil Data\", MRM 1994. https://doi.org/10.1002/mrm.1910320308\n\n\n\n\n\n","category":"method"},{"location":"methods/#MRIFieldmaps.spdiff-Tuple{Tuple{Vararg{Int64, N}} where N}","page":"Methods","title":"MRIFieldmaps.spdiff","text":"spdiff(dims::Dims; order=1, kwargs...)\n\nReturn Vector of length(dims) sparse finite-difference matrices of order order, one for each dimension.\n\nTypically one will vcat the vector output to make a sparse finite-difference matrix suitable for the vec of a multi-dimensional array.\n\nThe kwargs are passed to spdiff1 (for order = 1) or spdiff2 (for order = 2). These functions are called once for each dimension. The options are ending and T.\n\nExamples:\n\nspdiff((4,5,6))[1] == kron(I(6*5), spdiff1(4))\nspdiff((4,5,6); order=1)[2] == kron(I(6), spdiff1(5), I(4))\nspdiff((4,5,6); order=2)[3] == kron(spdiff2(6), I(4*5))\n\n\n\n\n\n","category":"method"},{"location":"methods/#MRIFieldmaps.spdiff1-Tuple{Int64}","page":"Methods","title":"MRIFieldmaps.spdiff1","text":"spdiff1(n::Int; ending::Symbol = :remove, T::Type = Int32)\n\nSparse n × n matrix for 1st-order finite differences.\n\nOption\n\nT element type, default Int32 to save memory\nending\n:remove (default) remove first difference\n:zero keep first row, akin to zero boundary conditions\n\n\n\n\n\n","category":"method"},{"location":"methods/#MRIFieldmaps.spdiff2-Tuple{Int64}","page":"Methods","title":"MRIFieldmaps.spdiff2","text":"spdiff2(n::Int; ending::Symbol = :remove, T::Type = Int32)\n\nSparse n × n matrix for 2nd-order finite differences.\n\nOption\n\nT element type, default Int32 to save memory\nending\n:remove (default) remove first and last finite difference\n:zero keep first and last rows, akin to zero boundary conditions\n:first use 1st-order finite differences for first and last rows\n\n\n\n\n\n","category":"method"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"EditURL = \"../../../lit/examples/01-overview.jl\"","category":"page"},{"location":"generated/examples/01-overview/#01-overview","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"This page summarizes the Julia package MRIFieldmaps.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"This page comes from a single Julia file: 01-overview.jl.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"You can access the source code for such Julia documentation using the 'Edit on GitHub' link in the top right. You can view the corresponding notebook in nbviewer here: 01-overview.ipynb, or open it in binder here: 01-overview.ipynb.","category":"page"},{"location":"generated/examples/01-overview/#Setup","page":"MRIFieldmaps overview","title":"Setup","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"Packages needed here. Use Pkg.add as illustrated here when using a package for the first time.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"using MRIFieldmaps: spdiff\nusing MIRTjim: jim, prompt; jim(:prompt, true)\nusing InteractiveUtils: versioninfo","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"The following line is helpful when running this file as a script; this way it will prompt user to hit a key after each figure is displayed.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"isinteractive() ? jim(:prompt, true) : prompt(:draw);\nnothing #hide","category":"page"},{"location":"generated/examples/01-overview/#Overview","page":"MRIFieldmaps overview","title":"Overview","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"This package provides algorithms for estimating fieldmaps in MRI. Currently it supports B0 map estimation. A future extension could support B1+ map estimation.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"This page just discusses the regularization; other examples illustrate specific fieldmap estimators.","category":"page"},{"location":"generated/examples/01-overview/#Regularization","page":"MRIFieldmaps overview","title":"Regularization","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"Some methods in this package use sparse matrices to perform finite-difference operations. Those operations could be performed with a LinearMap based on diff, but the fastest algorithms here use preconditioning based on incomplete Cholesky factorization of a Hessian matrix, and such factorization is supported for sparse matrices, but probably not for general linear maps.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"It may be helpful to visualize these sparse matrices.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"Here are 1D 1st-order and 2nd-order finite differences.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"D1 = spdiff((8,); order=1)[1]\nD2 = spdiff((8,); order=2)[1]\nclim = (-1, 2)\ncolor = :cividis\njim(\n jim(Matrix(D1)', \"1st-order\"; color, clim, prompt=false),\n jim(Matrix(D2)', \"2nd-order\"; color, clim, prompt=false),\n)","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"There are other boundary conditions available:","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"D1z = spdiff((8,); order=1, ending=:zero)[1]\nD2z = spdiff((8,); order=2, ending=:zero)[1]\nD2f = spdiff((8,); order=2, ending=:first)[1]\njim(\n jim(Matrix(D1z)', \"1st-order, zero ends\"; color, clim, prompt=false),\n jim(Matrix(D2z)', \"2nd-order, zero ends\"; color, clim, prompt=false),\n jim(Matrix(D2f)', \"2nd-order, 1st ends\"; color, clim, prompt=false),\n ; layout = (3,1),\n)","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"For multi-dimensional arrays, regularizers need finite-differences along each dimension, and these are constructed with Kronecker products and are applied to the vec of an array.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"dims = (9,8)\nd1 = spdiff(dims; order=1)\nd2 = spdiff(dims; order=2)\njim(\n jim(Matrix(d1[1])', \"1st-order, 1st dim\"; color, clim, prompt=false),\n jim(Matrix(d1[2])', \"1st-order, 2nd dim\"; color, clim, prompt=false),\n jim(Matrix(d2[1])', \"2nd-order, 1st dim\"; color, clim, prompt=false),\n jim(Matrix(d2[2])', \"2nd-order, 2nd dim\"; color, clim, prompt=false),\n)","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"Here is an illustration of applying these finite-difference matrices to a simple test phantom. Note the use of vec and reshape for display.","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"dims = (40,30)\nx = LinRange(-1, 1, dims[1])\ny = LinRange(-1, 1, dims[2])\nphantom = @. abs(x) + abs(y') < 0.5\npl = Array{Any}(undef, 2, 2)\nfor order in 1:2, d in 1:2\n    sp = spdiff(dims; order)\n    dif = reshape(sp[d] * vec(phantom), dims)\n    pl[d,order] = jim(x, y, dif, \"dim$d differences\\norder=$order\")\nend\npp = jim(x, y, phantom, \"Test image\")\njim([[pp pp]; pl]...)","category":"page"},{"location":"generated/examples/01-overview/#Support-mask","page":"MRIFieldmaps overview","title":"Support mask","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"Often we want to estimate a fieldmap over some spatial support \"mask\" that is smaller than the entire image, e.g., only in voxels where the signal is sufficiently large. See the ImageGeoms.jl documentation about the related embed and maskit operations.","category":"page"},{"location":"generated/examples/01-overview/#Reproducibility","page":"MRIFieldmaps overview","title":"Reproducibility","text":"","category":"section"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"This page was generated with the following version of Julia:","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"using InteractiveUtils: versioninfo\nio = IOBuffer(); versioninfo(io); split(String(take!(io)), '\\n')","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"And with the following package versions","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"import Pkg; Pkg.status()","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"","category":"page"},{"location":"generated/examples/01-overview/","page":"MRIFieldmaps overview","title":"MRIFieldmaps overview","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MRIFieldmaps","category":"page"},{"location":"#MRIFieldmaps.jl-Documentation","page":"Home","title":"MRIFieldmaps.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This Julia package (MRIFieldmaps) provides tools for estimating fieldmaps in MRI.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the \"Examples\" for details.","category":"page"}]
}
